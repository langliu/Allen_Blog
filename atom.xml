<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Allen&#39;s blog</title>
  
  <subtitle>我的个人博客，用于记录在学习中的一些知识，加强记忆</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://langliu.github.io/"/>
  <updated>2019-10-12T18:50:31.604Z</updated>
  <id>https://langliu.github.io/</id>
  
  <author>
    <name>Allen Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pandas入门</title>
    <link href="https://langliu.github.io/2018/08/29/pandas%E5%85%A5%E9%97%A8/"/>
    <id>https://langliu.github.io/2018/08/29/pandas入门/</id>
    <published>2018-08-29T22:46:07.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DataFrame数据选择"><a href="#DataFrame数据选择" class="headerlink" title="DataFrame数据选择"></a>DataFrame数据选择</h2><h3 id="选择行"><a href="#选择行" class="headerlink" title="选择行"></a>选择行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = DataFrame(&#123;</span><br><span class="line">    <span class="string">'name'</span>: [<span class="string">'Allen'</span>, <span class="string">'Marry'</span>, <span class="string">'Jack'</span>, <span class="string">'Jason'</span>, <span class="string">'Cherry'</span>, <span class="string">'Aline'</span>, <span class="string">'Timmy'</span>, <span class="string">'Alain'</span>],</span><br><span class="line">    <span class="string">'sex'</span>: [<span class="string">'m'</span>, <span class="string">'f'</span>, <span class="string">'m'</span>, <span class="string">'m'</span>, <span class="string">'f'</span>, <span class="string">'f'</span>, <span class="string">'m'</span>, <span class="string">'m'</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="获取前n行"><a href="#获取前n行" class="headerlink" title="获取前n行"></a>获取前n行</h4><p><code>df.head(n: int)</code>，该方法获取DataFrame的前n行（默认为5）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df.head(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#      name sex</span></span><br><span class="line"><span class="comment">#  0  Allen   m</span></span><br><span class="line"><span class="comment">#  1  Marry   f</span></span><br><span class="line"><span class="comment">#  2   Jack   m</span></span><br></pre></td></tr></table></figure><h4 id="获取后n行"><a href="#获取后n行" class="headerlink" title="获取后n行"></a>获取后n行</h4><p><code>df.tail(n :int)</code>，该方法获取DataFrame的后n行（默认为5）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df.tail(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#      name sex</span></span><br><span class="line"><span class="comment">#  5  Aline   f</span></span><br><span class="line"><span class="comment">#  6  Timmy   m</span></span><br><span class="line"><span class="comment">#  7  Alain   m</span></span><br></pre></td></tr></table></figure><h4 id="获取中间行"><a href="#获取中间行" class="headerlink" title="获取中间行"></a>获取中间行</h4><p>获取中间行有两种方式： <code>df.iloc[]</code> 和 <code>df.loc[]</code></p><p><code>df.iloc[]</code> 是根据 <code>index</code> 来划分的，而 <code>df.loc[]</code> 是根据 <code>label</code> 划分的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[<span class="number">1</span>:<span class="number">3</span>, :]  <span class="comment"># 获取第2，3行数据</span></span><br><span class="line"><span class="comment">#      name sex</span></span><br><span class="line"><span class="comment">#  1  Marry   f</span></span><br><span class="line"><span class="comment">#  2   Jack   m</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df.loc[<span class="number">1</span>:<span class="number">3</span>, :]  <span class="comment"># 获取第1，2，3行数据</span></span><br><span class="line"><span class="comment">#      name sex</span></span><br><span class="line"><span class="comment">#  1  Marry   f</span></span><br><span class="line"><span class="comment">#  2   Jack   m</span></span><br><span class="line"><span class="comment">#  3   Jason   m</span></span><br></pre></td></tr></table></figure><h3 id="选择列"><a href="#选择列" class="headerlink" title="选择列"></a>选择列</h3><h4 id="获取某一列"><a href="#获取某一列" class="headerlink" title="获取某一列"></a>获取某一列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'name'</span>]  <span class="comment"># 根据列名获取</span></span><br></pre></td></tr></table></figure><h4 id="获取多列"><a href="#获取多列" class="headerlink" title="获取多列"></a>获取多列</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[[<span class="string">'name'</span>, <span class="string">'sex'</span>]]  <span class="comment"># 根据列名获取</span></span><br></pre></td></tr></table></figure><h4 id="获取中间列"><a href="#获取中间列" class="headerlink" title="获取中间列"></a>获取中间列</h4><p>获取中间列有两种方式： <code>df.iloc[]</code> 和 <code>df.loc[]</code></p><p><code>df.iloc[]</code> 是根据 <code>index</code> 来划分的，而 <code>df.loc[]</code> 是根据 <code>label</code> 划分的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[:, <span class="number">0</span>:<span class="number">2</span>]  <span class="comment"># 获取第1，2列数据</span></span><br><span class="line"><span class="comment">#      name sex</span></span><br><span class="line"><span class="comment">#  1  Marry   f</span></span><br><span class="line"><span class="comment">#  2   Jack   m</span></span><br><span class="line"><span class="comment">#  3   Jason   m</span></span><br><span class="line"><span class="comment">#  4  Cherry   f</span></span><br><span class="line"><span class="comment">#  5   Aline   f</span></span><br><span class="line"><span class="comment">#  6   Timmy   m</span></span><br><span class="line"><span class="comment">#  7   Alain   m</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df.loc[:, :<span class="string">'name'</span>]  <span class="comment"># 获取第2，3行数据</span></span><br><span class="line"><span class="comment">#      name</span></span><br><span class="line"><span class="comment">#  1  Marry</span></span><br><span class="line"><span class="comment">#  2   Jack</span></span><br><span class="line"><span class="comment">#  3   Jason</span></span><br><span class="line"><span class="comment">#  4  Cherry</span></span><br><span class="line"><span class="comment">#  5   Aline</span></span><br><span class="line"><span class="comment">#  6   Timmy</span></span><br><span class="line"><span class="comment">#  7   Alain</span></span><br></pre></td></tr></table></figure><h2 id="重置编号"><a href="#重置编号" class="headerlink" title="重置编号"></a>重置编号</h2><h3 id="Series重置编号"><a href="#Series重置编号" class="headerlink" title="Series重置编号"></a>Series重置编号</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = Series([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>])</span><br><span class="line"><span class="comment"># A    1</span></span><br><span class="line"><span class="comment"># B    2</span></span><br><span class="line"><span class="comment"># C    3</span></span><br><span class="line"><span class="comment"># D    4</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br></pre></td></tr></table></figure><p><code>reindex()</code> 方法接收一个新的 <code>index</code> 列表，用于替换原来的 <code>index</code> ，如果新的 <code>index</code> 长度大于原来的 <code>index</code> 则新增的一行默认填充为 <code>NaN</code> ，可以通过指定参数 <code>fill_value</code> 改变默认的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1.reindex(index=[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>])</span><br><span class="line"><span class="comment"># A    1.0</span></span><br><span class="line"><span class="comment"># B    2.0</span></span><br><span class="line"><span class="comment"># C    3.0</span></span><br><span class="line"><span class="comment"># D    4.0</span></span><br><span class="line"><span class="comment"># E    NaN</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1.reindex(index=[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>], fill_value=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># A    1</span></span><br><span class="line"><span class="comment"># B    2</span></span><br><span class="line"><span class="comment"># C    3</span></span><br><span class="line"><span class="comment"># D    4</span></span><br><span class="line"><span class="comment"># E    0</span></span><br><span class="line"><span class="comment"># dtype: int64</span></span><br></pre></td></tr></table></figure><p>重置编号时使用 <code>method=&#39;ffill&#39;</code> 参数可以自动填充Series的值，如下例所示：因<code>index</code> 1，3，5有值，所以填充时1-3之间的填充 <code>index</code> 为1的值，3-5之间的填充 <code>index</code> 为3的值，而 <code>index</code> 为1的因为前面没有值，则为 <code>NaN</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s2 = Series([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>], index=[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">s2 = s2.reindex(index=range(<span class="number">5</span>), method=<span class="string">'ffill'</span>)</span><br><span class="line"><span class="comment"># 0    NaN</span></span><br><span class="line"><span class="comment"># 1      A</span></span><br><span class="line"><span class="comment"># 2      A</span></span><br><span class="line"><span class="comment"># 3      B</span></span><br><span class="line"><span class="comment"># 4      B</span></span><br><span class="line"><span class="comment"># dtype: object</span></span><br></pre></td></tr></table></figure><p>如果要删除某一行可以使用 <code>drop()</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s2.drop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DataFrame数据选择&quot;&gt;&lt;a href=&quot;#DataFrame数据选择&quot; class=&quot;headerlink&quot; title=&quot;DataFrame数据选择&quot;&gt;&lt;/a&gt;DataFrame数据选择&lt;/h2&gt;&lt;h3 id=&quot;选择行&quot;&gt;&lt;a href=&quot;#选择行&quot; c
      
    
    </summary>
    
      <category term="Python" scheme="https://langliu.github.io/categories/Python/"/>
    
    
      <category term="数据分析" scheme="https://langliu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="Pandas" scheme="https://langliu.github.io/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Nginx在Windows下开机自动启动</title>
    <link href="https://langliu.github.io/2018/08/26/Nginx%E5%9C%A8Windows%E4%B8%8B%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8/"/>
    <id>https://langliu.github.io/2018/08/26/Nginx在Windows下开机自动启动/</id>
    <published>2018-08-26T11:40:59.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>在<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">Nginx官网下载页面</a>下载Nginx Windows版本，下载后解压，然后运行目录下的 <code>nginx.exe</code> 启动nginx，这时打开浏览器输入 <code>http://localhost:80/</code> 就可以看见nginx的欢迎页面，说明nginx已经成功启动了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ow4hqwlyg.bkt.clouddn.com/nginx.png?limgeslim" alt="nginx" title>                </div>                <div class="image-caption">nginx</div>            </figure><h2 id="Windows下开机自启动"><a href="#Windows下开机自启动" class="headerlink" title="Windows下开机自启动"></a>Windows下开机自启动</h2><p>关闭计算机后重新打开电脑，这时如果再去访问 <code>http://localhost:80/</code> 会报 <code>404</code> 错误，因为关机后再次开机并不会自动重启Nginx，如果我们需要每次开机后启动Nginx怎么办呢？难道一次次的去nginx目录下运行nginx.exe吗，不，我们有更简单的方式：</p><p>我们可以借助<a href="https://github.com/kohsuke/winsw/releases" target="_blank" rel="noopener">Windows Service Wrapper</a>小工具，将Nginx转换为Windows服务，这样就可以在开机时自动启动Nginx了。</p><p>下载后将该工具放入Nginx的安装目录下，并且将其重命名为 <code>nginx-service.exe</code> ，在该目录下新建 <code>nginx-service.xml</code> 文件，写入配置信息，配置好了之后就可以通过这个将Nginx注册为Windows服务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nginx-service.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">service</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nginx<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>nginx<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>nginx<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logpath</span>&gt;</span>D:nginx-1.14.0\<span class="tag">&lt;/<span class="name">logpath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logmode</span>&gt;</span>roll<span class="tag">&lt;/<span class="name">logmode</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">depend</span>&gt;</span><span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executable</span>&gt;</span>D:nginx-1.14.0\nginx.exe<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stopexecutable</span>&gt;</span>D:nginx-1.14.0\nginx.exe -s stop<span class="tag">&lt;/<span class="name">stopexecutable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务命令"><a href="#服务命令" class="headerlink" title="服务命令"></a>服务命令</h3><p>以上内容配置好了之后，在nginx安装目录下以管理员运行命令：<code>.\nginx-service.exe install</code> 就成功将其注册为Windows服务了，然后运行 <code>.\nginx-service.exe start</code> 启动服务。这时我们可以在Windows任务管理器的服务中查看该是否成功启动。</p><p><strong>注：</strong></p><ul><li><code>nginx-service.exe install</code> 命令可注册对应的系统服务</li><li><code>nginx-service.exe uninstall</code> 命令可删除对应的系统服务</li><li><code>nginx-service.exe stop</code> 命令可停止对应的系统服务</li><li><code>nginx-service.exe start</code> 命令可启动对应的系统服务</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装Nginx&quot;&gt;&lt;a href=&quot;#安装Nginx&quot; class=&quot;headerlink&quot; title=&quot;安装Nginx&quot;&gt;&lt;/a&gt;安装Nginx&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;http://nginx.org/en/download.html&quot; targe
      
    
    </summary>
    
      <category term="环境配置" scheme="https://langliu.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>vue-cli3 设置反向代理</title>
    <link href="https://langliu.github.io/2018/08/25/Vue-CLI3%E8%AE%BE%E7%BD%AE%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>https://langliu.github.io/2018/08/25/Vue-CLI3设置反向代理/</id>
    <published>2018-08-25T15:55:02.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>最近在项目中使用了Vue CLI 3.0版本，项目中需要设置反向代理解决跨域问题，下面记录一下设置过程。</p><a id="more"></a><h2 id="新建配置文件"><a href="#新建配置文件" class="headerlink" title="新建配置文件"></a>新建配置文件</h2><p>在项目的根目录下新建 <code>vue.config.js</code> 文件，自Vue CLI 3开始，项目中所有的配置信息都写在这个文件中（2在config目录中配置）。</p><h2 id="配置反向代理"><a href="#配置反向代理" class="headerlink" title="配置反向代理"></a>配置反向代理</h2><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    <span class="comment">// 设置代理</span></span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">"/v1"</span>: &#123;</span><br><span class="line">        target: <span class="string">"http://127.0.0.1:8081/"</span>, <span class="comment">// 域名</span></span><br><span class="line">        ws: <span class="literal">true</span>, <span class="comment">// 是否启用websockets</span></span><br><span class="line">        changOrigin: <span class="literal">true</span>, <span class="comment">//开启代理：在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题</span></span><br><span class="line">        pathRequiresRewrite: &#123;</span><br><span class="line">          <span class="string">"^/v1"</span>: <span class="string">"/"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="在请求中使用"><a href="#在请求中使用" class="headerlink" title="在请求中使用"></a>在请求中使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// '/v1'等于'http://127.0.0.1:8081/v1'</span></span><br><span class="line"><span class="comment">// 此时请求地址为'http://127.0.0.1:8081/v1/picture?method=upload'</span></span><br><span class="line"><span class="keyword">get</span>('/v1/picture?method=upload')</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>更多内容请参考Vue CLI官方文档<a href="https://cli.vuejs.org/zh/config/#devserver-proxy" target="_blank" rel="noopener">https://cli.vuejs.org/zh/config/#devserver-proxy</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在项目中使用了Vue CLI 3.0版本，项目中需要设置反向代理解决跨域问题，下面记录一下设置过程。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Vue" scheme="https://langliu.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Numpy中的数组</title>
    <link href="https://langliu.github.io/2018/07/29/Numpy%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <id>https://langliu.github.io/2018/07/29/Numpy中的数组/</id>
    <published>2018-07-29T23:28:21.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>NumPy 中定义的最重要的对象是称为 <code>ndarray</code> 的N维数组类型。它描述相同类型的元素集合。可以使用基于零的索引访问集合中的项目。</p><a id="more"></a><p><code>ndarray</code> 中的每个元素在内存中使用相同大小的块。 <code>ndarray</code>中的每个元素是数据类型对象的对象(称为 <code>dtype</code>)。</p><p>从 <code>ndarray</code> 对象提取的任何元素(通过切片)由一个数组标量类型的 Python 对象表示。</p><h2 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>通过已有列表创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">list_1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">array_1 = np.array(list_1)  <span class="comment"># 1x4的一维数组</span></span><br><span class="line">array_2 = np.array([list_1, [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])  <span class="comment"># 2x4的二维数组</span></span><br></pre></td></tr></table></figure><p>通过 <code>arange()</code> 创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_3 = np.arange(<span class="number">5</span>)  <span class="comment"># [0 1 2 3 4]</span></span><br><span class="line">array_4 = np.arange(<span class="number">2</span>, <span class="number">5</span>)  <span class="comment"># [2 3 4]</span></span><br><span class="line">array_5 = np.arange(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>)  <span class="comment"># [1 3 5 7 9]</span></span><br></pre></td></tr></table></figure><p>通过 <code>zeros()</code> 创建全零数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array_6 = np.zeros(<span class="number">5</span>)  <span class="comment"># [0. 0. 0. 0. 0.]</span></span><br><span class="line">array_7 = np.zeros([<span class="number">2</span>, <span class="number">3</span>])  <span class="comment"># 2x3的全零数组</span></span><br></pre></td></tr></table></figure><p>通过 <code>eye()</code> 创建单位数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_8 = np.eye(<span class="number">3</span>)  <span class="comment"># 3x3的单位数组</span></span><br></pre></td></tr></table></figure><p>通过 <code>random.randn()</code> 创建随机数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_9 = np.random.randn(<span class="number">5</span>)  <span class="comment"># 会生成一个一行五列的随机数数组</span></span><br></pre></td></tr></table></figure><p>通过 <code>random.randint()</code> 创建随机数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array_10 = np.random.randint(<span class="number">6</span>, size=(<span class="number">3</span>, <span class="number">2</span>))  <span class="comment"># 生成一个元素小于6的3行2列的随机数组</span></span><br><span class="line">array_10 = np.random.randint(<span class="number">6</span>, size=<span class="number">3</span>)  <span class="comment"># 生成一个元素小于6的1行3列的随机数组</span></span><br></pre></td></tr></table></figure><h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>获取数组的轴数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_8.ndim  <span class="comment"># 3 表明数组有3列</span></span><br></pre></td></tr></table></figure><p>获取数组的形状：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array_6.shape  <span class="comment"># (5,) 表明array_6是一个 1x5 的数组</span></span><br><span class="line">array_8.shape  <span class="comment"># (3, 3) 表明array_8是一个 3x3 的数组</span></span><br></pre></td></tr></table></figure><p>获取数组的大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_8.size  <span class="comment"># 9 表明array_8有9个元素</span></span><br></pre></td></tr></table></figure><p>获数组元素的数据类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array_5.dtype  <span class="comment"># int32</span></span><br><span class="line">array_8.dtype  <span class="comment"># float64</span></span><br></pre></td></tr></table></figure><p>获取数组中的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array_1[<span class="number">0</span>]  <span class="comment"># 1 获取一维数组的第一个元素</span></span><br><span class="line">array_2[<span class="number">0</span>]  <span class="comment"># [1 2 3 4] 获取二维数组的第一行的元素</span></span><br><span class="line">array_2[<span class="number">1</span>][<span class="number">2</span>]  <span class="comment"># 3 获取二维数组第二行第三列的元素</span></span><br><span class="line">array_2[<span class="number">0</span>][:<span class="number">2</span>]  <span class="comment"># [1 2 3] 获取二维数组第一行的前三个元素</span></span><br><span class="line">array_2[:,:<span class="number">3</span>]  <span class="comment"># [[1 2 3] [1 2 3]] 获取数组第一行第一个元素至最后一行第3个元素区域的元素</span></span><br></pre></td></tr></table></figure><h3 id="数组运算"><a href="#数组运算" class="headerlink" title="数组运算"></a>数组运算</h3><p>数组的加减法和乘法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr_1 = np.array([1, 2, 3])</span><br><span class="line">arr_2 = np.array([4, 5, 6])</span><br><span class="line">arr_sum = arr_1 + arr_2  # [5, 7, 9]</span><br><span class="line">arr_sub = arr_2 - arr_1  # [3, 3, 3]</span><br><span class="line">arr_mul = arr_1 * arr_2  # [4 10 18]</span><br></pre></td></tr></table></figure><p>数组的除法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr_mul = arr_1 / arr_2  <span class="comment"># [0.25 0.4 0.5]</span></span><br><span class="line">arr_3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>]</span><br><span class="line">arr_mul1 = arr_1 / arr_3  <span class="comment"># [ 1.  1. inf] 除数为0时python会报警告，然后对应的结果为 `inf`</span></span><br></pre></td></tr></table></figure><h3 id="数组的常用方法"><a href="#数组的常用方法" class="headerlink" title="数组的常用方法"></a>数组的常用方法</h3><p>重置数组的形状： <code>ndarry.reshape()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr_4 = np.random.randint(<span class="number">10</span>, size=<span class="number">20</span>).reshape(<span class="number">4</span>, <span class="number">5</span>)  <span class="comment"># 生成一个4x5的随机数组</span></span><br></pre></td></tr></table></figure><p>求数组中的元素：<code>np.unique(ndarray)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr_5 = np.array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">arr_5_unique = np.unique(arr_5)  <span class="comment"># [1 2 3 5]</span></span><br></pre></td></tr></table></figure><p>数组求和：<code>sum(ndarray)</code></p><p>对于一维数组直接求取所有元素的和，对于二维数组则求取每列元素的和，返回一个新的数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(arr_5)  <span class="comment"># 12</span></span><br><span class="line">arr_6 = np.array([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">sum(arr_6)  <span class="comment"># [ 2  6 10  4  2]</span></span><br></pre></td></tr></table></figure><p>求数组中元素的最大值：<code>ndarray.max()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr_6.max()  <span class="comment"># 5</span></span><br><span class="line">max(arr_6[<span class="number">0</span>])  <span class="comment"># 5 求取第一行的最大值</span></span><br><span class="line">max(arr_6[:, <span class="number">0</span>])  <span class="comment"># 1 求取第一列的最大值</span></span><br></pre></td></tr></table></figure><h3 id="数组的文件读写："><a href="#数组的文件读写：" class="headerlink" title="数组的文件读写："></a>数组的文件读写：</h3><p>单个数组的读写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">np.save(<span class="string">'arr.npy'</span>, arr)</span><br><span class="line">a = np.load(<span class="string">'arr.npy'</span>)  <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br></pre></td></tr></table></figure><p>多个数组的读写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr_1 = np.arange(<span class="number">10</span>)</span><br><span class="line">arr_2 = np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">np.savez(<span class="string">'arr.npz'</span>, x=arr_1, y=arr_2)</span><br><span class="line">a = np.load(<span class="string">'arr.npz'</span>)</span><br><span class="line">print(a[<span class="string">'x'</span>])  <span class="comment"># [0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">print(a[<span class="string">'y'</span>])  <span class="comment"># [0 2 4 6 8]</span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>如果数组创建时同时包含 <code>int</code> 和 <code>float</code> 类型的元素，则数组创建后所有元素都将被转为 <code>float</code> 类型。只有只包含 <code>int</code> 类型的元素的数组的元素才为 <code>int</code> 类型。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NumPy 中定义的最重要的对象是称为 &lt;code&gt;ndarray&lt;/code&gt; 的N维数组类型。它描述相同类型的元素集合。可以使用基于零的索引访问集合中的项目。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://langliu.github.io/categories/Python/"/>
    
    
      <category term="NumPy" scheme="https://langliu.github.io/tags/NumPy/"/>
    
  </entry>
  
  <entry>
    <title>Python中的循环</title>
    <link href="https://langliu.github.io/2018/06/28/Python%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF/"/>
    <id>https://langliu.github.io/2018/06/28/Python中的循环/</id>
    <published>2018-06-28T00:44:09.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>Python中的循环有两种： <code>while</code> 和 <code>for</code> ，同其他语言不同的是，这两种方式可以联合 <code>else</code> 语句一起使用。</p><a id="more"></a><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>使用 <code>while</code> 时如果想要输出1-10的数字，我们可以使用以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> counter &lt; <span class="number">10</span>:</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    print(counter)</span><br></pre></td></tr></table></figure><p>当输出1-10之后程序结束运行，如果想要在 <code>while</code> 语句结束后输出一个结束标志怎么办呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> counter &lt; <span class="number">10</span>:</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    print(counter)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p><code>for</code> 语句主要用来遍历/循环 序列、字典或者集合</p><p>如果要向上面那样输出1-10，如以下代码所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    print(num)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><p>如果在 <code>for</code> 语句中想要获取数组的下标，可以使用Python内置的 <code>enumerate()</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate(range(<span class="number">1</span>,<span class="number">11</span>)):</span><br><span class="line">    print(<span class="string">'index: %s, value: %s'</span> % (index, value))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>在循环中， <code>break</code> 语句可以提前退出循环。例如，本来要循环打印1～10的数字，如果要在6之后退出循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    print(num)</span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>在循环过程中，也可以通过 <code>continue</code> 语句，跳过当前的这次循环，直接开始下一次循环,如果我们要打印1-10中的奇数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">    <span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(num)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python中的循环有两种： &lt;code&gt;while&lt;/code&gt; 和 &lt;code&gt;for&lt;/code&gt; ，同其他语言不同的是，这两种方式可以联合 &lt;code&gt;else&lt;/code&gt; 语句一起使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://langliu.github.io/categories/Python/"/>
    
    
      <category term="Python语法" scheme="https://langliu.github.io/tags/Python%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回文十进制数</title>
    <link href="https://langliu.github.io/2018/05/16/%E5%9B%9E%E6%96%87%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <id>https://langliu.github.io/2018/05/16/回文十进制数/</id>
    <published>2018-05-16T00:21:51.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果把某个数的各个数字按相反的顺序排列，得到的数和原来的数相同，则这个数就是“回文数”。譬如123454321就是一个回文数。</p><p>求用十进制、二进制、八进制表示都是回文数的所有数字中，大于十进制数10的最小值。</p><a id="more"></a><h2 id="解题方案："><a href="#解题方案：" class="headerlink" title="解题方案："></a>解题方案：</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ul><li>将该数分别转换为十进制、二进制、八进制表示，分别判断是否为回文数，如果该数的十进制、二进制、八进制表示都是回文数的话则该数满足条件</li><li>将该数转换为二进制时，第一位是1，如果该数是回文数的话则该数的最后一位也为1，所以该数只能为奇数</li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">@author: Allen</span></span><br><span class="line"><span class="string">@contact: 809721414@qq.com</span></span><br><span class="line"><span class="string">@time: 2018/5/14 10:15</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindromes_binary_number</span><span class="params">(number: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    判断一个数的是否为二进制回文数</span></span><br><span class="line"><span class="string">     :param number: int(要判断的数字)</span></span><br><span class="line"><span class="string">    :return: bool(判断结果)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; palindromes_binary_number(5)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; palindromes_binary_number(6)</span></span><br><span class="line"><span class="string">    False</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; palindromes_binary_number(7)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    bin_number = bin(number)</span><br><span class="line">    new_list = list(bin_number[<span class="number">2</span>:])</span><br><span class="line">    new_list.reverse()</span><br><span class="line">    <span class="keyword">return</span> bin_number[<span class="number">2</span>:] == list_to_str(new_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindromes_octal_number</span><span class="params">(number: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    判断一个数的是否为八进制回文数</span></span><br><span class="line"><span class="string">     :param number: int(要判断的数字)</span></span><br><span class="line"><span class="string">    :return: bool(判断结果)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; palindromes_octal_number(9)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; palindromes_binary_number(14)</span></span><br><span class="line"><span class="string">    False</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; palindromes_binary_number(7)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    oct_number = oct(number)</span><br><span class="line">    new_list = list(oct_number[<span class="number">2</span>:])</span><br><span class="line">    new_list.reverse()</span><br><span class="line">    <span class="keyword">return</span> oct_number[<span class="number">2</span>:] == list_to_str(new_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">palindromes_decimal_number</span><span class="params">(number: int)</span> -&gt; bool:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    判断一个整数是否为十进制回文数</span></span><br><span class="line"><span class="string">    :param number: int(要判断的数字)</span></span><br><span class="line"><span class="string">    :return: bool(判断结果)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; palindromes_decimal_number(11)</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; palindromes_decimal_number(12)</span></span><br><span class="line"><span class="string">    False</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    new_list = list(str(number))</span><br><span class="line">    new_list.reverse()</span><br><span class="line">    <span class="keyword">return</span> number == int(list_to_str(new_list))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_to_str</span><span class="params">(one_list: list)</span> -&gt; str:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将列表转为字符串</span></span><br><span class="line"><span class="string">    :param one_list: list(要转换的列表)</span></span><br><span class="line"><span class="string">    :return: str(转换后的字符串)</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list_to_str([1, 2, 3])</span></span><br><span class="line"><span class="string">    '123'</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; list_to_str([12, '123', 1324])</span></span><br><span class="line"><span class="string">    '121231324'</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(list(map(str, one_list)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> doctest</span><br><span class="line"></span><br><span class="line">    doctest.testmod(verbose=<span class="literal">True</span>)</span><br><span class="line">    num = <span class="number">11</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> palindromes_decimal_number(num) <span class="keyword">and</span> palindromes_binary_number(num) <span class="keyword">and</span> palindromes_octal_number(num):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num = num + <span class="number">2</span></span><br><span class="line">    print(num)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;如果把某个数的各个数字按相反的顺序排列，得到的数和原来的数相同，则这个数就是“回文数”。譬如123454321就是一个回文数。&lt;/p&gt;
&lt;p&gt;求用十进制、二进制、八进制表示都是回文数的所有数字中，大于十进制数10的最小值。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://langliu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://langliu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Flow来检测你的Js</title>
    <link href="https://langliu.github.io/2018/01/17/%E4%BD%BF%E7%94%A8Flow%E6%9D%A5%E6%A3%80%E6%B5%8B%E4%BD%A0%E7%9A%84Js/"/>
    <id>https://langliu.github.io/2018/01/17/使用Flow来检测你的Js/</id>
    <published>2018-01-17T23:53:11.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>最近在一篇文章上看见了关于Flow的介绍，觉得它很不错，虽然之前在项目中使用Typescript已经很顺手了，再使用Flow感觉有点累赘了，但多学点总是没错的。</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JS作为一种脚本语言是没有类型检测的，这个特点有时候用着很爽，但当你在一个较大的项目中的时候，就会发现这其实是一件挺糟糕的事情，因为和你协作的程序员往往不太清楚你所写的代码到底哪种类型才是正确的，而且代码重构的时候也很麻烦。于是基于这个需求有了Typescript和Flow的产生，今天这里主要介绍Flow。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>因为笔者一直使用的是WebStorm，WebStorm内部对Flow就有一定的支持，所以如果你也使用WebStorm的话会方便很多。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add --dev flow-bin babel-cli babel-preset-flow</span><br></pre></td></tr></table></figure><p>在安装了上述的包之后，创建 <code>.babelrc</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"flow"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置WebStorm"><a href="#设置WebStorm" class="headerlink" title="设置WebStorm"></a>设置WebStorm</h3><p>通过 <code>File&gt;Settings&gt;Languages&amp;Frameworks&gt;JavaScript</code> 如下图所示设置，Flow package可以选择你项目下的flow-bin，当然你也可以全局安装flow-bin，然后在这里设置后就可以在每个项目中都使用Flow了 。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3737324-89b828243cb790c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Flow-Settings" title>                </div>                <div class="image-caption">Flow-Settings</div>            </figure></p><p>flow不能直接在node或浏览器环境中使用，所以我们必须用babel编译后才能使用：<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3737324-7f2ee5f2bb67697d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snipaste_2018-01-15_23-54-48.png" title>                </div>                <div class="image-caption">Snipaste_2018-01-15_23-54-48.png</div>            </figure></p><p>现在环境已经快配好了，只剩最后一步，将一个此项目初始化为一个Flow项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn run flow init</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://upload-images.jianshu.io/upload_images/3737324-e48ca84f2d035f8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Snipaste_2018-01-16_00-00-14.png" title>                </div>                <div class="image-caption">Snipaste_2018-01-16_00-00-14.png</div>            </figure><p>现在当我们在项目中使用Flow时WebStorm可以给出智能的提示了。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>最新的 ECMAScript 标准定义了 7 种数据类型:</p><ul><li><p>6 种 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" title="原始类型: A primitive (primitive value, primitive data type) is data that is not an object and has no methods. In JavaScript, there are 6 primitive data types: string, number, boolean, null, undefined, symbol (new in ECMAScript 2015)." target="_blank" rel="noopener">原始类型</a>:</p><ul><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Boolean" title="Boolean: In computer science, a boolean is a logical data type that can have only the values true or false." target="_blank" rel="noopener">Boolean</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Null" title="Null: In computer science, a null value represents a reference that points, generally intentionally, to a nonexistent or invalid object or address. The meaning of a null reference varies among language implementations." target="_blank" rel="noopener">Null</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Undefined" title="Undefined: A primitive value automatically assigned to variables that have just been declared or to formal arguments for which there are no actual arguments." target="_blank" rel="noopener">Undefined</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Number" title="Number: In JavaScript, Number is a numeric data type in the double-precision 64-bit floating point format (IEEE 754). In other programming languages different numeric types can exist, for examples: Integers, Floats, Doubles, or Bignums." target="_blank" rel="noopener">Number</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/String" title="String: In any computer programming language, a string is a sequence of characters used to represent text." target="_blank" rel="noopener">String</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol" target="_blank" rel="noopener">Symbol</a> (ECMAScript 6 新定义)</li></ul></li><li><p>和 <a href="https://developer.mozilla.org/en-US/docs/Glossary/Object" title="Object: Object refers to a data structure containing data and instructions for working with the data. Objects sometimes refer to real-world things, for example a car or map object in a racing game. JavaScript, Java, C++, Python, and Ruby are examples of object-oriented programming languages." target="_blank" rel="noopener">Object</a></p></li></ul><p>在Flow中也是使用这几种类型作为标注:</p><p>使用原始类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">x: number, y: string, z: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method(<span class="number">3.14</span>, <span class="string">"hello"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>使用对象类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">method</span>(<span class="params">x: Number, y: String, z: Boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">method(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">42</span>), <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"world"</span>), <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>));</span><br></pre></td></tr></table></figure><p>这里需要注意的是大小写，小写的 <code>number</code> 是原始类型，而大写的 <code>Number</code> 是JavaScript的构造函数，是对象类型的。</p><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>在Flow中，默认并不会转换类型，如果你需要转换类型请使用显示或隐式转换，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acceptsBoolean</span>(<span class="params">value: boolean</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">acceptsBoolean(<span class="literal">true</span>);  <span class="comment">// Works!</span></span><br><span class="line">acceptsBoolean(<span class="literal">false</span>); <span class="comment">// Works!</span></span><br><span class="line">acceptsBoolean(<span class="string">"foo"</span>); <span class="comment">// Error!</span></span><br><span class="line">acceptsBoolean(<span class="built_in">Boolean</span>(<span class="string">"foo"</span>)); <span class="comment">// Works!</span></span><br><span class="line">acceptsBoolean(!!(<span class="string">"foo"</span>)); <span class="comment">// Works!</span></span><br></pre></td></tr></table></figure><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acceptsNumber</span>(<span class="params">value: number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">acceptsNumber(<span class="number">42</span>);       <span class="comment">// Works!</span></span><br><span class="line">acceptsNumber(<span class="number">3.14</span>);     <span class="comment">// Works!</span></span><br><span class="line">acceptsNumber(<span class="literal">NaN</span>);      <span class="comment">// Works!</span></span><br><span class="line">acceptsNumber(<span class="literal">Infinity</span>); <span class="comment">// Works!</span></span><br><span class="line">acceptsNumber(<span class="string">"foo"</span>);    <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><h4 id="null和void"><a href="#null和void" class="headerlink" title="null和void"></a>null和void</h4><p>JavaScript兼有 <code>null</code> 和 <code>undefined</code>。Flow将这些视为单独的类型：<code>null</code> 和 <code>void</code>（void表示undefined类型）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acceptsNull</span>(<span class="params">value: null</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acceptsUndefined</span>(<span class="params">value: void</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">acceptsNull(<span class="literal">null</span>);      <span class="comment">// Works!</span></span><br><span class="line">acceptsNull(<span class="literal">undefined</span>); <span class="comment">// Error!</span></span><br><span class="line">acceptsUndefined(<span class="literal">null</span>);      <span class="comment">// Error!</span></span><br><span class="line">acceptsUndefined(<span class="literal">undefined</span>); <span class="comment">// Works!</span></span><br></pre></td></tr></table></figure><h4 id="也许类型"><a href="#也许类型" class="headerlink" title="也许类型"></a>也许类型</h4><p>也许类型是用于可选值的地方，你可以通过在类型前添加一个问号（如 <code>?string</code> 或者 <code>?number</code>）来创建它们。</p><p>除了问号 <code>?</code> 后跟着的类型，也许类型也可以是 <code>null</code> 或者 <code>void</code> 类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acceptsMaybeString</span>(<span class="params">value: ?string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">acceptsMaybeString(<span class="string">"bar"</span>);     <span class="comment">// Works!</span></span><br><span class="line">acceptsMaybeString(<span class="literal">undefined</span>); <span class="comment">// Works!</span></span><br><span class="line">acceptsMaybeString(<span class="literal">null</span>);      <span class="comment">// Works!</span></span><br><span class="line">acceptsMaybeString();          <span class="comment">// Works!</span></span><br></pre></td></tr></table></figure><h4 id="可选的对象属性"><a href="#可选的对象属性" class="headerlink" title="可选的对象属性"></a>可选的对象属性</h4><p>对象类型可以具有可选属性，问号 <code>?</code> 位于属性名称后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; propertyName?: string &#125;</span><br></pre></td></tr></table></figure><p>除了它们的设定值类型之外，这些可选属性也可以被 <code>void</code> 完全省略。但是，他们不能 <code>null</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acceptsObject</span>(<span class="params">value: &#123; foo?: string &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">acceptsObject(&#123; <span class="attr">foo</span>: <span class="string">"bar"</span> &#125;); <span class="comment">// Works!</span></span><br><span class="line">acceptsObject(&#123; <span class="attr">foo</span>: <span class="literal">undefined</span> &#125;); <span class="comment">// Works!</span></span><br><span class="line">acceptsObject(&#123; <span class="attr">foo</span>: <span class="literal">null</span> &#125;); <span class="comment">// Error!</span></span><br><span class="line">acceptsObject(&#123;&#125;); <span class="comment">// Works!</span></span><br></pre></td></tr></table></figure><h4 id="可选的函数参数"><a href="#可选的函数参数" class="headerlink" title="可选的函数参数"></a>可选的函数参数</h4><p>函数可以具有可选参数，其中问号 <code>?</code> 出现在参数名称后面。同样，该参数不能为 <code>null</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acceptsOptionalString</span>(<span class="params">value?: string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">acceptsOptionalString(<span class="string">"bar"</span>);     <span class="comment">// Works!</span></span><br><span class="line">acceptsOptionalString(<span class="literal">undefined</span>); <span class="comment">// Works!</span></span><br><span class="line">acceptsOptionalString(<span class="literal">null</span>);      <span class="comment">// Error!</span></span><br><span class="line">acceptsOptionalString();          <span class="comment">// Works!</span></span><br></pre></td></tr></table></figure><h4 id="文字类型"><a href="#文字类型" class="headerlink" title="文字类型"></a>文字类型</h4><p>文字类型使用一个具体的值作为类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">value: <span class="number">2</span></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>); <span class="comment">// Work!</span></span><br><span class="line">foo(<span class="number">3</span>); <span class="comment">// Error!</span></span><br><span class="line">foo(<span class="string">'2'</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><p>您可以使用这些类型的原始值：</p><ul><li>布尔人：  <code>true</code> 或 <code>false</code> </li><li>数字：像 <code>42</code> 或 <code>3.14</code></li><li>字符串：像 <code>&quot;foo&quot;</code> 或 <code>&quot;bar&quot;</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span>(<span class="params">name: <span class="string">"success"</span> | <span class="string">"warning"</span> | <span class="string">"danger"</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"success"</span> : <span class="keyword">return</span> <span class="string">"green"</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"warning"</span> : <span class="keyword">return</span> <span class="string">"yellow"</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"danger"</span>  : <span class="keyword">return</span> <span class="string">"red"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getColor(<span class="string">"success"</span>); <span class="comment">// Works!</span></span><br><span class="line">getColor(<span class="string">"danger"</span>);  <span class="comment">// Works!</span></span><br><span class="line"><span class="comment">// $ExpectError</span></span><br><span class="line">getColor(<span class="string">"error"</span>);   <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><h4 id="混合类型-mixed"><a href="#混合类型-mixed" class="headerlink" title="混合类型 mixed"></a>混合类型 <code>mixed</code></h4><p>有时候我们并不能确定需要的值到底是哪种类型，这时候我们可以使用混合类型来表示，但在使用该值之前，我们需要判断该值到底是哪种类型，否则会引起错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">value: mixed</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $ExpectError</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">""</span> + value; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stringify(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">value: mixed</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span> + value; <span class="comment">// Works!</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stringify(<span class="string">"foo"</span>);</span><br></pre></td></tr></table></figure><h4 id="任意类型-any"><a href="#任意类型-any" class="headerlink" title="任意类型 any"></a>任意类型 <code>any</code></h4><p>如果你想要一种方法来选择不使用类型检查器，<code>any</code> 是做到这一点的方法。</p><blockquote><p>使用any是完全不安全的，应尽可能避免。</p></blockquote><p>例如，下面的代码不会报告任何错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">one: any, two: any</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> one + two;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);     <span class="comment">// Works.</span></span><br><span class="line">add(<span class="string">"1"</span>, <span class="string">"2"</span>); <span class="comment">// Works.</span></span><br><span class="line">add(&#123;&#125;, []);   <span class="comment">// Works.</span></span><br></pre></td></tr></table></figure><h4 id="接口类型-interface"><a href="#接口类型-interface" class="headerlink" title="接口类型 interface"></a>接口类型 <code>interface</code></h4><p>你可以使用 <code>interface</code> 以声明您期望的类的结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line">interface Serializable &#123;</span><br><span class="line">  serialize(): string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  serialize() &#123; <span class="keyword">return</span> <span class="string">'[Foo]'</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  serialize() &#123; <span class="keyword">return</span> <span class="string">'[Bar]'</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo: Serializable = <span class="keyword">new</span> Foo(); <span class="comment">// Works!</span></span><br><span class="line"><span class="keyword">const</span> bar: Serializable = <span class="keyword">new</span> Bar(); <span class="comment">// Works!</span></span><br></pre></td></tr></table></figure><p>你也可以使用 <code>implements</code> 告诉Flow，你希望类匹配一个接口。这可以防止编辑类时发生不兼容的更改。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @flow</span></span><br><span class="line">interface Serializable &#123;</span><br><span class="line">  serialize(): string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  serialize() &#123; <span class="keyword">return</span> <span class="string">'[Foo]'</span>; &#125; <span class="comment">// Works!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// $ExpectError</span></span><br><span class="line">  serialize() &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125; <span class="comment">// Error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组类型-Array"><a href="#数组类型-Array" class="headerlink" title="数组类型 Array"></a>数组类型 <code>Array</code></h4><p>要创建一个数组类型，可以使用 <code>Array&lt;Type&gt;</code> 类型，其中 <code>Type</code> 是数组中元素的类型。例如，为你使用的数字数组创建一个类型 <code>Array&lt;number&gt;</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>暂时就介绍这么多，还有一些类型文章中没有提到，更多更详细的内容请在<a href="https://flow.org/en/" target="_blank" rel="noopener">Flow官网</a>中查看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在一篇文章上看见了关于Flow的介绍，觉得它很不错，虽然之前在项目中使用Typescript已经很顺手了，再使用Flow感觉有点累赘了，但多学点总是没错的。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://langliu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>HTML5.2新特性</title>
    <link href="https://langliu.github.io/2018/01/10/HTML5-2%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://langliu.github.io/2018/01/10/HTML5-2新特性/</id>
    <published>2018-01-10T23:12:16.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>在去年的12月份W3C组织发布了HTML5.2版本，这个版本对之前的规范又有了一些添加和修改，有些有意思的内容可以极大的方便我们的编码，下面我们一起来看一看这些变化。具体的变化可以在<a href="https://www.w3.org/TR/html52/changes.html#changes" target="_blank" rel="noopener">这里</a>看见。</p><a id="more"></a><h2 id="新增标签"><a href="#新增标签" class="headerlink" title="新增标签"></a>新增标签</h2><h3 id="dialog"><a href="#dialog" class="headerlink" title="dialog"></a><code>dialog</code></h3><p><code>dialog</code> 标签可以帮助我们快速的实现一个对话框，在之前如果我们想要实现一个对话框，大都是先写一个 <code>div</code> 元素，然后设置CSS将其隐藏，在需要显示时再改变其CSS属性将其显示，而如果使用 <code>dialog</code> 标签只需要几行代码就可以实现这个功能：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">id</span>=<span class="string">"dialog"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个dialog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"close-dialog"</span>&gt;</span>关闭对话框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>打开对话框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> dialog = <span class="built_in">document</span>.getElementById(<span class="string">'dialog'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> closeDialog = <span class="built_in">document</span>.getElementById(<span class="string">'close-dialog'</span>);</span></span><br><span class="line"><span class="actionscript">    btn.onclick = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">        dialog.show();</span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'open dialog'</span>);</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    closeDialog.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line">        dialog.close();</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当点击打开对话框按钮打开对话框后，页面就像下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://ow4hqwlyg.bkt.clouddn.com/Snipaste_2018-01-11_23-07-51.png" alt="dialog" title>                </div>                <div class="image-caption">dialog</div>            </figure><p>如果想要关闭对话框只需要调用 <code>close()</code> 方法，如果想要对话框在一开始的时候就显示，只需要给 <code>dialog</code> 元素添加 <code>open</code> 属性即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dialog</span> <span class="attr">id</span>=<span class="string">"dialog"</span> <span class="attr">open</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个dialog<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"close-dialog"</span>&gt;</span>关闭对话框<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dialog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当使用 <code>show()</code> 方法打开dialog的时候我们还是可以点击对话框外的其他内容，如果我们不想在打开对话框的时候屏幕的其他内容可以点击，要给他加一个遮罩层该怎么办呢？很简单，我们只需要使用 <code>showModal()</code> 方法来打开dialog就好。使用 <code>showModal()</code> 方法打开的dialog在显示对话框的同时，会在你页面的顶层显示一个遮罩层，以防止你去操作除对话框以外的它元素。</p><p>有一点需要注意的地方是当你给 <code>dialog</code> 元素添加 <code>open</code> 属性后，就不能够再去调用 <code>showModal()</code> 方法来打开dialog，否则会报一个 <code>Untitled-1.html:28 Uncaught DOMException: Failed to execute &#39;showModal&#39; on &#39;HTMLDialogElement&#39;: The element already has an &#39;open&#39; attribute, and therefore cannot be opened modally.</code> 的错。</p><h2 id="已删除的内容"><a href="#已删除的内容" class="headerlink" title="已删除的内容"></a>已删除的内容</h2><ul><li>keygen，menu和menuitem元素。</li><li>在inputmode对文本属性的input元素和dropzone属性。</li><li>该showModalDialog方法。</li><li>插件API已被标记为废弃。</li></ul><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><ul><li>停止非网络来源的媒体资源请求延迟 <code>load</code> 事件。</li><li>删除刷新率的任意上限。</li><li>坐标 <code>ismap</code> 不再包含计算中的图像边界。</li><li>将<code>accesskey</code>定义更新为需要单个可打印的字符。</li><li>修复激活算法 <code>summary</code> 以符合实际。</li><li>修复算法以确定行和列标题 <code>table</code>。</li><li>更新渲染 <code>summary</code></li><li>反映破损的URL会返回未解析的值</li><li><code>currentScript</code> 可能会返回 <code>SVGScriptElement</code>。</li><li>重置一个 <code>textarea</code> 重置它的脏值标志。</li><li><code>document.open()</code> 并 <code>document.close()</code> 检查XML文档。</li><li><code>HashChangeEvent</code> 网址是，<code>USVString</code> 而不是 <code>DOMString</code>。</li><li>选择成员的类型是可空的。</li><li>data: 网址被视为一个单独的来源。</li><li>可悲的是，只有具有tabindex属性的元素通常不会click在用非指针设备激活时触发事件。</li><li>导航沙盒上下文</li><li><code>role</code>根据 <code>[html-aria]</code> 更新的允许值</li><li><code>&lt;style&gt;</code> 标签位于 <code>&lt;body&gt;</code>之内。</li><li>多个 <code>&lt;main&gt;</code> 标签在DOM元素中，只要只有一个是对用户可见。</li><li><code>&lt;img&gt;</code> 元素的演示。</li><li><code>&lt;div&gt;</code> 作为一个 <code>&lt;dl&gt;</code> 元素的子元素。</li><li><code>&lt;dfn&gt;</code> 作为 <code>&lt;li&gt;</code> 包含定义的术语定义的元素的后代。</li><li><code>&lt;legend&gt;</code> 在一个内部的标题<code>&lt;fieldset&gt;</code>。</li><li><code>&lt;option&gt;</code> 作为孩子的空元素 <code>&lt;datalist&gt;</code>。</li><li>在HTML语法中包含两个连续的连字符的注释或以连字符结尾的注释。</li><li>去除BiDi算法部分的限制</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在去年的12月份W3C组织发布了HTML5.2版本，这个版本对之前的规范又有了一些添加和修改，有些有意思的内容可以极大的方便我们的编码，下面我们一起来看一看这些变化。具体的变化可以在&lt;a href=&quot;https://www.w3.org/TR/html52/changes.html#changes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;看见。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML5" scheme="https://langliu.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>Python中的list和tuple</title>
    <link href="https://langliu.github.io/2018/01/04/Python%E4%B8%AD%E7%9A%84list%E5%92%8Ctuple/"/>
    <id>https://langliu.github.io/2018/01/04/Python中的list和tuple/</id>
    <published>2018-01-04T22:52:55.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>Python内置的一种数据类型是列表：list。list是Python的一种叫法，和其他语言中的数组一样，是一种有序的数据集合，可以随时向其中添加和删除元素。</p><a id="more"></a><p> 一个基本的表示姓名的list：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Allen'</span>, <span class="string">'Youngor'</span>, <span class="string">'Jack'</span>]</span><br></pre></td></tr></table></figure><p>可以用<code>len()</code>函数获得list元素的个数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(names) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>使用索引来访问list中每一个位置的元素，索引从0开始，如果从最后一个元素开始获取元素，可以用负数表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names[<span class="number">0</span>] <span class="comment"># 'Allen'</span></span><br><span class="line">names[<span class="number">1</span>] <span class="comment"># 'Youngor'</span></span><br><span class="line">names[<span class="number">-1</span>] <span class="comment"># 'Jack'</span></span><br><span class="line">names[<span class="number">-2</span>] <span class="comment"># 'Youngor'</span></span><br></pre></td></tr></table></figure><p>当索引超出了范围时，Python会报一个<code>IndexError</code>错误，所以，要确保索引不要越界。</p><p>如果要删除列表中的一个元素，可以使用 <code>del</code> 语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">del</span> nums[<span class="number">1</span>]</span><br><span class="line">print(nums) <span class="comment"># [1, 3, 4]</span></span><br></pre></td></tr></table></figure><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>在使用list的时候，我们可能会经常需要取出list的某一部分元素，如果用循环去取的话非常笨重，Python为我们提供了一个非常方便的方法取出list的一部分，那就是切片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[start:end:step]</span><br></pre></td></tr></table></figure><p>切片方法可以有三个参数：</p><ul><li>start：起始位置（需要截取的list的开始位置）</li><li>end：结束位置（需要截取的list的结束位置，结果不包括该位置的值）</li><li>step：步长（每个步长取一个元素，默认为1）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从索引3开始取，到索引5为止</span></span><br><span class="line">nums[<span class="number">3</span>:<span class="number">5</span>] <span class="comment"># [4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从第0个元素开始，直到最后一个元素，每两个元素取一个</span></span><br><span class="line">nums[::<span class="number">2</span>] <span class="comment"># [1, 3, 5, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 索引也可以使用负数表示</span></span><br><span class="line">nums[<span class="number">-3</span>:<span class="number">-1</span>] <span class="comment"># [5, 6]</span></span><br></pre></td></tr></table></figure><h4 id="重复列表"><a href="#重复列表" class="headerlink" title="重复列表"></a>重复列表</h4><p>在Python中，如果要创建一个长度为10的list，并其list的每个元素全初始化为0，应该怎么做？</p><p>在其他的语言中你可能是使用循环来创建，但是在Python中只要一行代码就可以轻松创建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">0</span>] * <span class="number">10</span> <span class="comment"># [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span></span><br></pre></td></tr></table></figure><h4 id="判断元素是否在列表中"><a href="#判断元素是否在列表中" class="headerlink" title="判断元素是否在列表中"></a>判断元素是否在列表中</h4><p>在Python中可以使用 <code>in</code> 操作符判断一个元素是否存在于一个列表中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Allen'</span>, <span class="string">'Youngor'</span>, <span class="string">'Lvy'</span>]</span><br><span class="line">print(<span class="string">'Allen'</span> <span class="keyword">in</span> names) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h4 id="组合列表"><a href="#组合列表" class="headerlink" title="组合列表"></a>组合列表</h4><p>在Python中，我们可以使用 <code>+</code> 运算符将两个list组合在一起，像连接两个字符串一样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">num2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">print(num1 + num2) <span class="comment"># [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h4 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h4><p>要生成一些简单的列表我们可以通过 <code>list(range(10))</code> 这种方式，但是如果我们需要一个幂数列的列表呢？</p><p>在其他语言中，我们只能通过循环的方式来生成，但是在python中却有一种更简单的方式来生成这种复杂的列表，那就是列表生成式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">print(l) <span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure><p>for循环后面还可以加上if判断，这样我们可以快速的选出我们想要的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">3</span> == <span class="number">0</span>]</span><br><span class="line">print(l) <span class="comment"># [9, 36, 81]</span></span><br></pre></td></tr></table></figure><p>还可以使用两层循环，可以生成全排列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l = [m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">print(l) <span class="comment"># ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ']</span></span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h4><p><code>append(value)</code> 方法向list末尾追加一个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.append(<span class="string">'Lvy'</span>) <span class="comment"># ['Allen', 'Youngor', 'Jack', 'Lvy']</span></span><br></pre></td></tr></table></figure><h4 id="insert"><a href="#insert" class="headerlink" title="insert()"></a>insert()</h4><p><code>insert(index, value)</code> 方法把元素插入到list中指定的位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.insert(<span class="number">1</span>, <span class="string">'Bob'</span>) <span class="comment"># ['Allen', 'Bob', 'Youngor', 'Jack']</span></span><br></pre></td></tr></table></figure><h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p><code>pop(index)</code> 方法删除ist中指定位置的元素，如果要删除末尾的元素，则可以不传入索引位置。该方法返回删除的元素的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names.pop(<span class="number">1</span>) <span class="comment"># 'Youngor'</span></span><br><span class="line">names.pop() <span class="comment"># 'Jack'</span></span><br></pre></td></tr></table></figure><h4 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h4><p><code>count(value)</code> 方法用作统计某个元素在列表中出现的次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.count(<span class="string">'Allen'</span>) <span class="comment"># 1</span></span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p><code>remove(value)</code> 方法移除列表中某个值的第一个匹配项：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names.remove(<span class="string">'Allen'</span>)</span><br><span class="line">print(names) <span class="comment"># ['Youngor', 'Jack']</span></span><br></pre></td></tr></table></figure><p>如果该元素不在列表中，则会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.remove(<span class="string">'Tom'</span>) <span class="comment"># ValueError: list.remove(x): x not in list</span></span><br></pre></td></tr></table></figure><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p><code>reverse()</code> 方法反向列表中元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names.reverse()</span><br><span class="line">print(names) <span class="comment"># ['Jack', 'Youngor', 'Allen']</span></span><br></pre></td></tr></table></figure><h4 id="index"><a href="#index" class="headerlink" title="index()"></a>index()</h4><p><code>index(value)</code> 方法从列表中找出某个值第一个匹配项的索引位置，如果列表中存在该值，返回该值的索引。如果该值不存在，抛出一个 <code>ValueError</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Allen'</span>, <span class="string">'Youngor'</span>, <span class="string">'Jack'</span>]</span><br><span class="line">print(names.index(<span class="string">'Allen'</span>)) <span class="comment"># 0</span></span><br><span class="line">print(names.index(<span class="string">'Tom'</span>)) <span class="comment"># ValueError: 'Tom' is not in list</span></span><br></pre></td></tr></table></figure><h4 id="extend"><a href="#extend" class="headerlink" title="extend()"></a>extend()</h4><p><code>extend(obj)</code> 方法在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表），需要传入的参数是一个可迭代对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Allen'</span>, <span class="string">'Youngor'</span>, <span class="string">'Jack'</span>]</span><br><span class="line">names.extend(<span class="string">'123'</span>)</span><br><span class="line">print(names) <span class="comment"># ['Allen', 'Youngor', 'Jack', '1', '2', '3']</span></span><br></pre></td></tr></table></figure><h4 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h4><p><code>clear()</code> 方法清除列表中所有的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names.clear()</span><br><span class="line">print(names) <span class="comment"># []</span></span><br></pre></td></tr></table></figure><h4 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h4><p><code>copy()</code> 方法用于拷贝一个list（深拷贝）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Allen'</span>, <span class="string">'Youngor'</span>, <span class="string">'Jack'</span>]</span><br><span class="line">names_copy = names.copy()</span><br><span class="line">names.append(<span class="string">'Tim'</span>)</span><br><span class="line">print(names_copy) <span class="comment"># ['Allen', 'Youngor', 'Jack']</span></span><br><span class="line">print(names) <span class="comment"># ['Allen', 'Youngor', 'Jack', 'Tim']</span></span><br></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p><code>sort(fun)</code> 方法对列表进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">56</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">nums.sort()</span><br><span class="line">print(nums) <span class="comment"># [1, 2, 4, 5, 23, 34, 56]</span></span><br></pre></td></tr></table></figure><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><p>tuple和list非常相似，但是tuple一旦初始化就不能修改，所以tuple必须在定义的时候就初始化完成。</p><p>同样表示姓名的tuple:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names = (<span class="string">'Allen'</span>, <span class="string">'Youngor'</span>, <span class="string">'Jack'</span>)</span><br></pre></td></tr></table></figure><p>同list一样，我们也可以通过索引取得tuple的元素的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names[<span class="number">0</span>] <span class="comment"># 'Allen'</span></span><br></pre></td></tr></table></figure><p>如果要定义一个只有一个元素的tuple，必须在结尾加一个<code>,</code>来消除歧义，因为<code>()</code>既可以表示tuple又可以表示数学公式中的小括号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = (<span class="number">1</span>) <span class="comment"># 1</span></span><br><span class="line">num = (<span class="number">1</span>,) <span class="comment"># (1,)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;list&quot;&gt;&lt;a href=&quot;#list&quot; class=&quot;headerlink&quot; title=&quot;list&quot;&gt;&lt;/a&gt;list&lt;/h2&gt;&lt;p&gt;Python内置的一种数据类型是列表：list。list是Python的一种叫法，和其他语言中的数组一样，是一种有序的数据集合，可以随时向其中添加和删除元素。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://langliu.github.io/categories/Python/"/>
    
    
      <category term="Python语法" scheme="https://langliu.github.io/tags/Python%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Video标签</title>
    <link href="https://langliu.github.io/2018/01/02/Video%E6%A0%87%E7%AD%BE/"/>
    <id>https://langliu.github.io/2018/01/02/Video标签/</id>
    <published>2018-01-02T23:28:45.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>关于HTML5中的 <code>video</code> 标签之前一直就知道它是HTML5的新特性，可是在之前的项目中一直也没有视频的内容，所以对其的印象不深，在这次的项目中，有大量的视频展示，所以在写项目时有用到较多的 <code>video</code> 标签，这次之后对其的了解加深了许多。</p><a id="more"></a><h2 id="一个简单的实例"><a href="#一个简单的实例" class="headerlink" title="一个简单的实例"></a>一个简单的实例</h2><p>直接使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"moive.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span>您的浏览器不支持video标签,请更新您的浏览器<span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配合 <code>source</code> 标签一起使用(source 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.mp4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"movie.ogg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><ul><li><code>controls</code>: 如果出现该属性,则向用户显示控件,比如播放按钮。</li><li><code>autoplay</code>: 如果出现该属性,则视频就绪后立刻播放</li><li><code>loop</code>: 如果出现该属性,则视频播放完成后会继续循环播放</li><li><code>preload</code>: 如果出现该属性,则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。</li><li><code>height</code>: 设置播放器的高度</li><li><code>width</code>: 设置播放器的宽度</li><li><code>poster</code>: 一个海报帧的URL，用于在用户播放或者跳帧之前展示。如果属性未指定，那么在第一帧可用之前什么都不会展示；之后第一帧就像海报帧一样展示。</li><li><code>muted</code>: 指明了视频里的音频的默认设置</li></ul><h2 id="通过JavaScript操作video"><a href="#通过JavaScript操作video" class="headerlink" title="通过JavaScript操作video"></a>通过JavaScript操作video</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><code>paly()</code>: 播放视频</li><li><code>pause()</code>: 暂停播放视频</li><li><code>load()</code>:</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><code>paused</code>: 布尔值,表示视频是否暂停播放</li><li><code>currentTime</code>: 数值,表示视频目前播放到多少时间</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于HTML5中的 &lt;code&gt;video&lt;/code&gt; 标签之前一直就知道它是HTML5的新特性，可是在之前的项目中一直也没有视频的内容，所以对其的印象不深，在这次的项目中，有大量的视频展示，所以在写项目时有用到较多的 &lt;code&gt;video&lt;/code&gt; 标签，这次之后对其的了解加深了许多。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTML5" scheme="https://langliu.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>跳台阶</title>
    <link href="https://langliu.github.io/2017/12/31/%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>https://langliu.github.io/2017/12/31/跳台阶/</id>
    <published>2017-12-31T23:51:41.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><a id="more"></a><h2 id="解题方案："><a href="#解题方案：" class="headerlink" title="解题方案："></a>解题方案：</h2><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><ul><li>当跳上第一级台阶时只有一种跳法，当跳上第二级台阶时有两种跳法</li><li>当第三级台阶时有两种方式：从第一级台阶跳两级；从第二级台阶跳一级。以此类推，后面的第n级台阶到达的方式应该是到第n-1级台阶和第n-2级台阶的方式的和<code>f(n) = f(n-1) + f(n-2)</code></li></ul><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jumpFloor</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (number &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'不能小于1'</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * result - 到达第number级台阶的跳法</span></span><br><span class="line"><span class="comment">     * a - 到达第number-2级台阶的跳法</span></span><br><span class="line"><span class="comment">     * b - 到达第number-1级台阶的跳法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">let</span> [result, a, b] = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 从第3级台阶开始，计算到达第index级台阶的跳法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">3</span>; index &lt;= number; index++) &#123;</span><br><span class="line">      <span class="comment">// 到达第index级台阶的跳法</span></span><br><span class="line">      result = a + b;</span><br><span class="line">      <span class="comment">// 跟新前两次的跳法</span></span><br><span class="line">      [a, b] = [b, result];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://langliu.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://langliu.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Web安全-XSS</title>
    <link href="https://langliu.github.io/2017/10/26/Web%E5%AE%89%E5%85%A8-XSS/"/>
    <id>https://langliu.github.io/2017/10/26/Web安全-XSS/</id>
    <published>2017-10-26T22:54:59.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS的攻击方式"><a href="#XSS的攻击方式" class="headerlink" title="XSS的攻击方式"></a>XSS的攻击方式</h2><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>发出请求时，XSS代码出现在URL中，作为输出提交到服务端，服务端解析响应后，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。</p><h3 id="储存型"><a href="#储存型" class="headerlink" title="储存型"></a>储存型</h3><p>存储型XSS和反射型XSS的差别仅在于提交的代码会存储在服务端，下次 请求目标页面是不用再次提交XSS代码。</p><a id="more"></a><h3 id="反射型示例"><a href="#反射型示例" class="headerlink" title="反射型示例"></a>反射型示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装express生成器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install --global express-generator</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成一个新的项目</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> express -e xss</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改模板文件 `index.ejs`</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;</span><br><span class="line">    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;%- xss %&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改路由配置文件 `index.js`</span></span><br><span class="line">var express = require("express");</span><br><span class="line">var router = express.Router();</span><br><span class="line"></span><br><span class="line">/* GET home page. */</span><br><span class="line">router.get("/", function(req, res, next) &#123;</span><br><span class="line">  res.render("index", &#123; title: "Express", xss: req.query.xss &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动项目</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm start</span></span><br></pre></td></tr></table></figure><p>当你通过浏览器url传入xss参数时，后端响应后传回给前端，前端直接绑定响应结果。可以通过这种方式在你也页面插入不安全的内容，比如说插入一个 <code>&lt;iframe&gt;</code> 窗口，使你的页面嵌入一些广告或其他内容。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Snipaste_2017-10-31_22-58-46.png" alt="XSS" title>                </div>                <div class="image-caption">XSS</div>            </figure></p><h2 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h2><ul><li>编码：<ul><li>对用户输入的数据进行HTML Entity编码</li></ul></li><li>过滤：<ul><li>移除用户上传的DOM属性，如onerror等</li><li>移除用户上传的Style节点、Script节点、Iframe节点等</li></ul></li><li>校正<ul><li>避免直接对HTML Entity解码</li><li>使用DOM Parse解码，校正不配对的DOM标签</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XSS的攻击方式&quot;&gt;&lt;a href=&quot;#XSS的攻击方式&quot; class=&quot;headerlink&quot; title=&quot;XSS的攻击方式&quot;&gt;&lt;/a&gt;XSS的攻击方式&lt;/h2&gt;&lt;h3 id=&quot;反射型&quot;&gt;&lt;a href=&quot;#反射型&quot; class=&quot;headerlink&quot; title=&quot;反射型&quot;&gt;&lt;/a&gt;反射型&lt;/h3&gt;&lt;p&gt;发出请求时，XSS代码出现在URL中，作为输出提交到服务端，服务端解析响应后，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。&lt;/p&gt;
&lt;h3 id=&quot;储存型&quot;&gt;&lt;a href=&quot;#储存型&quot; class=&quot;headerlink&quot; title=&quot;储存型&quot;&gt;&lt;/a&gt;储存型&lt;/h3&gt;&lt;p&gt;存储型XSS和反射型XSS的差别仅在于提交的代码会存储在服务端，下次 请求目标页面是不用再次提交XSS代码。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://langliu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript-Array类型</title>
    <link href="https://langliu.github.io/2017/10/22/JavaScript-Array%E7%B1%BB%E5%9E%8B/"/>
    <id>https://langliu.github.io/2017/10/22/JavaScript-Array类型/</id>
    <published>2017-10-22T14:54:25.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>在JavaScript中除了Object类型外Array类型是使用最多的类型了，但是一直对其中的方法没有记得很熟练，于是写下这篇文章来记一下。</p><a id="more"></a><h2 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h2><p>数组的创建有两种方式：字面量和构造函数</p><h3 id="构造函数方式"><a href="#构造函数方式" class="headerlink" title="构造函数方式"></a>构造函数方式</h3><p>构造函数接受零个或多个参数：</p><ul><li>当参数为零时，创建一个空数组；</li><li>当只有一个参数时，如果该参数为数字，则创建一个包含给定项数的数组，否则创建一个包含那个值的数组；</li><li>当参数为多个时，创建包含给定参数的数组。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'red'</span>,<span class="string">'green'</span>);</span><br></pre></td></tr></table></figure><h3 id="字面量方式"><a href="#字面量方式" class="headerlink" title="字面量方式"></a>字面量方式</h3><p>字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>,<span class="string">'green'</span>];</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h3><p>数组的length属性可以获取数组的项数，并且可以通过给该属性赋值来改变数组的项数。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><p><code>Array.from</code> 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, mapFn, thisArg)</span><br></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ul><li>arrayLike：想要转换成数组的伪数组对象或可迭代对象。</li><li>mapFn (可选参数)：如果指定了该参数，新数组中的每个元素会执行该回调函数。</li><li>thisArg (可选参数)：可选参数，执行回调函数 mapFn 时 this 对象。</li></ul><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><p>一个新的数组实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Array</span>.from(<span class="string">'123'</span>, value =&gt; <span class="built_in">Number</span>.parseInt(value) + <span class="number">3</span>); <span class="comment">// [4, 5, 6]</span></span><br></pre></td></tr></table></figure><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p><code>Array.isArray()</code> 用于确定传递的值是否是一个 Array。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(obj)</span><br></pre></td></tr></table></figure><h5 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h5><ul><li>obj：需要检测的值。</li></ul><h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h5><p>返回一个布尔值：如果对象是 <code>Array</code>，则为<code>true</code>; 否则为<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>]); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><p><code>Array.of()</code> 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。</p><h4 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(element0[, element1[, ...[, elementN]]])</span><br></pre></td></tr></table></figure><h5 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h5><ul><li>elementN：任意个参数，将按顺序成为返回数组中的元素。</li></ul><h5 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h5><p>新的 <code>Array</code> 实例</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在JavaScript中除了Object类型外Array类型是使用最多的类型了，但是一直对其中的方法没有记得很熟练，于是写下这篇文章来记一下。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://langliu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的this指向问题</title>
    <link href="https://langliu.github.io/2017/10/18/JavaScript%E7%9A%84this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/"/>
    <id>https://langliu.github.io/2017/10/18/JavaScript的this指向问题/</id>
    <published>2017-10-18T23:28:16.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>和许多常见的其他语言不一样，JavaScript的 this 指向不是在定义时就确定了的，而是在调用时确定的。</p><h2 id="指向"><a href="#指向" class="headerlink" title="指向"></a>指向</h2><h3 id="全局指向"><a href="#全局指向" class="headerlink" title="全局指向"></a>全局指向</h3><p>在严格模式下，默认的 this 指向 undefined ，在非严格模式下，默认的 this 指向 window</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">// 严格模式下为： undefined ；非严格模式为： 1</span></span><br></pre></td></tr></table></figure><h3 id="对象内部的指向"><a href="#对象内部的指向" class="headerlink" title="对象内部的指向"></a>对象内部的指向</h3><p>如果 this 是在对象内部定义的，一般来说 this 指向 this 定义时的上一级对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"Allen"</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName(); <span class="comment">// 'Allen'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"Allen"</span>,</span><br><span class="line">  getName: &#123;</span><br><span class="line">    name: <span class="string">"Youngor"</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName.fn(); <span class="comment">// 'Youngor'</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，第一个例子的 <code>this</code> 指向对象 <code>obj</code> ，第二个例子的 <code>this</code> 指向对象 <code>obj</code> 的属性 <code>getName</code>（因为该属性也是一个对象），如果 <code>getName</code> 属性中不存在对象属性 <code>name</code> ，那么 <code>this.name</code> 则为 <code>undefined</code> ，<code>this</code> 并不会在向上一级寻找。</p><p>有一种情况有点特殊，需要我们注意下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"Allen"</span>,</span><br><span class="line">  getName: &#123;</span><br><span class="line">    name: <span class="string">"Youngor"</span>,</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> fn = obj.getName.fn;</span><br><span class="line">fn(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>我们发现结果和我们预期的有点不一样，这是为什么呢？我们需要记住这句话 <strong>this永远指向的是最后调用它的对象</strong> ，在上面的例子中，我们把 <code>obj.getName.fn</code> 赋值给一个变量 <code>fn</code> ，通过这个变量来执行this，这时候最后调用它的对象已经从对象 <code>obj</code> 的属性 <code>getName</code> 变为全局对象了，所以执行的结果是 <code>undefined</code>。</p><h3 id="构造函数中的this"><a href="#构造函数中的this" class="headerlink" title="构造函数中的this"></a>构造函数中的this</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Allen"</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">21</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person.name); <span class="comment">// 'Allen'</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p><code>new</code> 关键字可以改变 this 的指向，将其指向新建的对象，在这里指向 <code>person</code> 对象</p><h3 id="当-this-遇见-return"><a href="#当-this-遇见-return" class="headerlink" title="当 this 遇见 return"></a>当 this 遇见 return</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Allen"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> fun();</span><br><span class="line"><span class="built_in">console</span>.log(f.name); <span class="comment">// 'Allen'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Allen"</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> fun();</span><br><span class="line"><span class="built_in">console</span>.log(f.name); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果返回值是一个对象，那么this指向的就是那个返回的对象（null除外）；如果返回值不是一个对象，那么this指向的还是那个函数的实例。</p><h3 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h3><p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 </p><h2 id="bind、apply、call对this的影响"><a href="#bind、apply、call对this的影响" class="headerlink" title="bind、apply、call对this的影响"></a>bind、apply、call对this的影响</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p><code>bind()</code>  的作用是将当前函数与指定的对象绑定，并返回一个新的函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">'hi'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> fun = test.bind(obj1); <span class="comment">// 第一次bind</span></span><br><span class="line">fun(); <span class="comment">// 'hi'</span></span><br><span class="line">fun.bind(&#123;<span class="attr">name</span>: <span class="string">'srd'</span>&#125;); <span class="comment">// 第二次bind</span></span><br><span class="line">fun(); <span class="comment">// 'hi'</span></span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p><code>call()</code> 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">fun.call(&#123; <span class="attr">name</span>: <span class="string">"Allen"</span> &#125;); <span class="comment">// 'Allen'</span></span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p><code>apply()</code> 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">fun.apply(&#123; <span class="attr">name</span>: <span class="string">"Allen"</span> &#125;); <span class="comment">// 'Allen'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和许多常见的其他语言不一样，JavaScript的 this 指向不是在定义时就确定了的，而是在调用时确定的。&lt;/p&gt;
&lt;h2 id=&quot;指向&quot;&gt;&lt;a href=&quot;#指向&quot; class=&quot;headerlink&quot; title=&quot;指向&quot;&gt;&lt;/a&gt;指向&lt;/h2&gt;&lt;h3 id=&quot;全局指向&quot;&gt;&lt;a href=&quot;#全局指向&quot; class=&quot;headerlink&quot; title=&quot;全局指向&quot;&gt;&lt;/a&gt;全局指向&lt;/h3&gt;&lt;p&gt;在严格模式下，默认的 this 指向 undefined ，在非严格模式下，默认的 this 指向 window&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://langliu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>配置CentOS云端NodeJS环境</title>
    <link href="https://langliu.github.io/2017/10/14/%E9%85%8D%E7%BD%AECentOS%E4%BA%91%E7%AB%AFNodeJS%E7%8E%AF%E5%A2%83/"/>
    <id>https://langliu.github.io/2017/10/14/配置CentOS云端NodeJS环境/</id>
    <published>2017-10-14T23:35:25.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>最近买了一个阿里云的云服务器，想要把自己的项目部署到阿里云上可以通过外网访问，阿里云上配置环境的时候有许多的不懂的地方，这是我配置环境的步骤，将此记下来：</p><a id="more"></a><h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 <code>Nginx</code></h2><p>在 <code>CentOS</code> 上，可直接使用 <code>yum</code> 来安装Nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx -y</span><br></pre></td></tr></table></figure><p>安装完成后，使用 <code>nginx</code> 命令启动 Nginx：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure><p>此时，访问 <a href="http://IP" target="_blank" rel="noopener">http://IP</a> 可以看到 Nginx 的测试页面。</p><p>如果此时不能访问，则是因为云服务器 ECS 未开放80端口，不能通过公网访问80端口，此时进入 <code>管理控制台/云服务器ECS/网络和安全/安全组</code> 添加一个新的规则，使之能够通过公网访问80端口，如果需要暴露其他端口，同样需要在安全组中配置安全规则。</p><h3 id="配置静态服务器访问路径"><a href="#配置静态服务器访问路径" class="headerlink" title="配置静态服务器访问路径"></a>配置静态服务器访问路径</h3><p>外网用户访问服务器的 Web 服务由 Nginx 提供，Nginx 需要配置静态资源的路径信息才能通过 url 正确访问到服务器上的静态资源。</p><p>打开 Nginx 的默认配置文件 <code>/etc/nginx/nginx.conf</code> ，修改 Nginx 配置，将默认的 <code>root /usr/share/nginx/html;</code> 修改为: <code>root /data/www;</code>，如下：<br>nginx.conf</p><p>配置文件将 <code>/data/www/static</code> 作为所有静态资源请求的根路径，如访问: <code>http://IP/static/index.js</code>，将会去 <code>/data/www/static/</code> 目录下去查找 <code>index.js</code>。现在我们需要重启 Nginx 让新的配置生效，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><p>重启后，现在我们应该已经可以使用我们的静态服务器了，现在让我们新建一个静态文件，查看服务是否运行正常。</p><p>首先让我们在 <code>/data</code> 目录 下创建 <code>www</code> 目录，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/www</span><br></pre></td></tr></table></figure><p>创建第一个静态文件<br>在 <code>/data/www</code> 目录下创建我们的第一个静态文件 <code>index.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在访问 <a href="http://IP/index.html" target="_blank" rel="noopener">http://IP/index.html</a> 应该可以看到页面输出 <code>Hello world!</code></p><p>到此，一个基于 Nginx 的静态服务器就搭建完成了，现在所有放在   <code>/data/www</code> 目录下的的静态资源都可以直接通过域名访问。</p><h2 id="安装最新版-git"><a href="#安装最新版-git" class="headerlink" title="安装最新版 git"></a>安装最新版 git</h2><p>在 CentOS 下可以使用 <code>yum</code> 命令直接安装 git ：<code>yum install git</code>，但是因为 yum 仓库的源比较旧，所以安装的 git 版本比较老，我最近使用 yum 安装的 git 的版本为 <code>1.8.3</code> ，而最新的版本为 <code>2.14.2</code> ，版本差了太多了。</p><h2 id="部署Node-js环境-使用NVM安装多版本"><a href="#部署Node-js环境-使用NVM安装多版本" class="headerlink" title="部署Node.js环境 - 使用NVM安装多版本"></a>部署Node.js环境 - 使用NVM安装多版本</h2><p>NVM（Node version manager）是Node.js的版本管理软件，使用户可以轻松在Node.js各个版本间进行切换。适用于长期做 node 开发的人员或有快速更新node版本、快速切换node版本这一需求的用户。</p><p>安装步骤：</p><p>1、直接使用git将源码克隆到本地的~/.nvm目录下，并检查最新版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br><span class="line">git clone https://github.com/cnpm/nvm.git ~/.nvm &amp;&amp; cd ~/.nvm &amp;&amp; git checkout `git describe --abbrev=0 --tags`</span><br></pre></td></tr></table></figure><p>2、激活NVM。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;. ~/.nvm/nvm.sh&quot; &gt;&gt; /etc/profile</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>3、列出Node.js的所有版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm list-remote</span><br></pre></td></tr></table></figure><p>4、安装多个Node.js版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nvm install v6.11.4</span><br><span class="line">nvm install v8.7.0</span><br></pre></td></tr></table></figure><p>5、查看已安装Node.js版本，当前使用的版本为v8.7.0。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZuf62didsxigy36d6kjtrZ .nvm]# nvm ls</span><br><span class="line">-&gt;       v6.11.4</span><br><span class="line">         v8.7.0</span><br></pre></td></tr></table></figure><p>6、切换Node.js版本至v6.11.4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZuf62didsxigy36d6kjtrZ .nvm]# nvm use v6.11.4</span><br><span class="line">Now using node v6.11.4</span><br></pre></td></tr></table></figure><h2 id="安装进程管理器"><a href="#安装进程管理器" class="headerlink" title="安装进程管理器"></a>安装进程管理器</h2><p>安装进程管理器以便控制Node.js应用程序，这个进程管理器可以保持应用程序一直在运行，运行以下命令进行安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># npm install pm2 -g</span></span><br></pre></td></tr></table></figure><h3 id="使用pm2启动进程"><a href="#使用pm2启动进程" class="headerlink" title="使用pm2启动进程"></a>使用pm2启动进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 start app.js // 该命令会保证 app.js 一直在后台运行</span><br></pre></td></tr></table></figure><h3 id="查看所有进程"><a href="#查看所有进程" class="headerlink" title="查看所有进程"></a>查看所有进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 list // 该命令会列出所有在后台运行的进程</span><br></pre></td></tr></table></figure><h2 id="安装Mongodb"><a href="#安装Mongodb" class="headerlink" title="安装Mongodb"></a>安装Mongodb</h2><h3 id="配置包管理系统（yum）"><a href="#配置包管理系统（yum）" class="headerlink" title="配置包管理系统（yum）"></a>配置包管理系统（yum）</h3><p>创建一个/etc/yum.repos.d/mongodb-org-3.4.repo文件，使您可以直接安装MongoDB。在文件中写入下面内容：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mongodb-org-<span class="number">3</span>.<span class="number">4</span>]</span><br><span class="line">name=MongoDB Repository</span><br><span class="line">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/<span class="number">3</span>.<span class="number">4</span>/x86_64/</span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgkey=https://www.mongodb.org/static/pgp/server-<span class="number">3</span>.<span class="number">4</span>.asc</span><br></pre></td></tr></table></figure><h3 id="安装MongoDB软件包和相关工具。"><a href="#安装MongoDB软件包和相关工具。" class="headerlink" title="安装MongoDB软件包和相关工具。"></a>安装MongoDB软件包和相关工具。</h3><p>要安装最新的稳定版本的MongoDB，请发出以下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y mongodb-org</span><br></pre></td></tr></table></figure><h3 id="数据目录和权限"><a href="#数据目录和权限" class="headerlink" title="数据目录和权限"></a>数据目录和权限</h3><p>MongoDB实例默认存储其数据文件/var/lib/mongo 及其日志文件/var/log/mongodb，并使用mongod 用户帐户运行。您可以在其中指定备用日志和数据文件目录/etc/mongod.conf。查看systemLog.path 和storage.dbPath获取更多信息。</p><p>如果更改运行MongoDB进程的用户，则 必须修改对/var/lib/mongo和 /var/log/mongodb目录的访问控制权限，以使该用户能够访问这些目录。</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="启动MongoDB。"><a href="#启动MongoDB。" class="headerlink" title="启动MongoDB。"></a>启动MongoDB。</h4><p>您可以mongod通过发出以下命令来启动该过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mongod start</span><br></pre></td></tr></table></figure><h4 id="验证MongoDB已经成功启动"><a href="#验证MongoDB已经成功启动" class="headerlink" title="验证MongoDB已经成功启动"></a>验证MongoDB已经成功启动</h4><p>您可以mongod通过检查日志文件的内容进行/var/log/mongodb/mongod.log 读取来验证进程是否成功启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[initandlisten] waiting for connections on port &lt;port&gt;</span><br></pre></td></tr></table></figure><p>其中<port>被配置为在该端口/etc/mongod.conf，27017默认情况下。</port></p><h4 id="停止MongoDB。"><a href="#停止MongoDB。" class="headerlink" title="停止MongoDB。"></a>停止MongoDB。</h4><p>根据需要，您可以mongod通过发出以下命令来停止进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mongod stop</span><br></pre></td></tr></table></figure><h4 id="重新启动MongoDB。"><a href="#重新启动MongoDB。" class="headerlink" title="重新启动MongoDB。"></a>重新启动MongoDB。</h4><p>您可以mongod通过发出以下命令重新启动该过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mongod restart</span><br></pre></td></tr></table></figure><p>您可以通过查看/var/log/mongodb/mongod.log文件中的输出来跟踪进程的状态，以查找错误或重要消息。    </p><h2 id="查看端口号"><a href="#查看端口号" class="headerlink" title="查看端口号"></a>查看端口号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anl|grep &quot;端口号&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近买了一个阿里云的云服务器，想要把自己的项目部署到阿里云上可以通过外网访问，阿里云上配置环境的时候有许多的不懂的地方，这是我配置环境的步骤，将此记下来：&lt;/p&gt;
    
    </summary>
    
      <category term="环境配置" scheme="https://langliu.github.io/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>前端跨域问题</title>
    <link href="https://langliu.github.io/2017/10/12/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://langliu.github.io/2017/10/12/前端跨域问题/</id>
    <published>2017-10-12T22:33:38.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>最近面试一直有被问到关于跨域的问题，自己了解的也不多，只知道可以通过jsonp可以解决，但对其具体怎么解决的却不太了解，于是花了一点时间专门研究了一下这个问题。</p><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>首先什么是跨域呢？协议、域名、端口都相同是同源，否则都是跨域。</p><a id="more"></a><h2 id="解决跨域的一些方法"><a href="#解决跨域的一些方法" class="headerlink" title="解决跨域的一些方法"></a>解决跨域的一些方法</h2><h3 id="图像Ping"><a href="#图像Ping" class="headerlink" title="图像Ping"></a>图像Ping</h3><p>一个网页可以从任何网页中加载图像，不用担心跨域不跨域。图像Ping就是利用 <code>&lt;img&gt;</code> 标签来与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容。通过图像Ping，浏览器得不到任何具体的数据，但可以监听 <code>load</code> 和 <code>error</code> 事件知道响应是什么时候接收到的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.src = <span class="string">'http://www.example.com/test?name=Allen'</span>;</span><br></pre></td></tr></table></figure><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>只能发送GET请求</li><li>无法访问服务器的响应文本</li></ul><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是JSON with padding（填充式JSON）的简写，是应用JSON的一种新方法。通过动态创建 <code>&lt;script&gt;</code> 标签来使用，使用时可以为其 <code>src</code> 属性指定一个跨域的URL。</p><p>JSONP由两部分组成：</p><ul><li>回调函数：当响应到来时在页面中调用的函数（回调函数的名字一般在请求中指定）</li><li>数据：传入回调函数中的JSON数据</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleResponse</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">script.src = <span class="string">'http://freegeoip.net/json/?callback=handleResponse'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.insertBefore(script,<span class="built_in">document</span>.body.firstChild);</span><br></pre></td></tr></table></figure><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP调用之外，没有办法追究。</li></ul><h3 id="跨域资源共享"><a href="#跨域资源共享" class="headerlink" title="跨域资源共享"></a>跨域资源共享</h3><p>CORS(Cross-Origin Resource Rharing)背后的思想是浏览器和服务端通过头部信息来进行沟通确认是否给予响应。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Origin: http:<span class="comment">//www.baidu.com    // 浏览器的头部信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果服务端认可这个域名的跨域请求，如下设置就可跨域访问资源</span></span><br><span class="line">Access-Control-Allow-Origin: http:<span class="comment">//www.baidu.com</span></span><br></pre></td></tr></table></figure><p>如上就可以实现最简单的跨域访问，但是此时不能携带任何的cookie，如果我们需要传递cookie进行身份认证，需要设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">true</span>;    <span class="comment">// 浏览器端</span></span><br><span class="line">Access-Control-Allow-Credentials: <span class="literal">true</span>;    <span class="comment">// 服务端</span></span><br></pre></td></tr></table></figure><p>这样我们就可以传递认证信息了，但如果允许认证，Access-Control-Allow-Origin不能设置为*，而一定是具体的域名信息。</p><h3 id="html5-postMessage方法"><a href="#html5-postMessage方法" class="headerlink" title="html5 postMessage方法"></a>html5 postMessage方法</h3><p>html5引入的message的API可以更方便、有效、安全的解决跨域问题。postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p><p>postMessage(data,origin)方法接受两个参数：</p><ul><li>data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化。</li><li>origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</li></ul><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.frames[<span class="number">0</span>].postMessage(<span class="string">"getcolor"</span>, <span class="string">"http://lslib.com"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="接受消息"><a href="#接受消息" class="headerlink" title="接受消息"></a>接受消息</h4><p>通过监听 <code>message</code> 事件来获取传入的消息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(</span><br><span class="line">  <span class="string">"message"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.source != <span class="built_in">window</span>.parent) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">let</span> color = container.style.backgroundColor;</span><br><span class="line">    <span class="built_in">window</span>.parent.postMessage(color, <span class="string">"*"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>传入的消息有几个重要属性：</p><ul><li>data：顾名思义，是传递来的message</li><li>source：发送消息的窗口对象</li><li>origin：发送消息窗口的源（协议+主机+端口号）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近面试一直有被问到关于跨域的问题，自己了解的也不多，只知道可以通过jsonp可以解决，但对其具体怎么解决的却不太了解，于是花了一点时间专门研究了一下这个问题。&lt;/p&gt;
&lt;h2 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域&quot;&gt;&lt;/a&gt;什么是跨域&lt;/h2&gt;&lt;p&gt;首先什么是跨域呢？协议、域名、端口都相同是同源，否则都是跨域。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://langliu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器内核</title>
    <link href="https://langliu.github.io/2017/09/25/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8/"/>
    <id>https://langliu.github.io/2017/09/25/浏览器内核/</id>
    <published>2017-09-25T16:56:16.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>前几天面试的时候面试官问到了关于浏览器内核的问题，当时他问的是有哪几种浏览器内核，但是我只知道WebKit一种，后来面试结束后一直想着这个问题，然后在网上了解了以下，下面是一些结果：</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>浏览器最重要或者说核心的部分是“Rendering Engine”，可大概译为“渲染引擎”，不过我们一般习惯将之称为“浏览器内核”。负责对网页语法的解释（如<a href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">标准通用标记语言</a>下的一个应用<a href="https://baike.baidu.com/item/HTML" target="_blank" rel="noopener">HTML</a>、<a href="https://baike.baidu.com/item/JavaScript" target="_blank" rel="noopener">JavaScript</a>）并渲染（显示）网页。 所以，通常所谓的<a href="https://baike.baidu.com/item/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8" target="_blank" rel="noopener">浏览器内核</a>也就是浏览器所采用的<a href="https://baike.baidu.com/item/%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">渲染引擎</a>，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="Webkit"><a href="#Webkit" class="headerlink" title="Webkit"></a>Webkit</h3><p>Webkit(Safari内核,Chrome内核原型,开源)<strong>:</strong>它是苹果公司自己的内核，也是苹果的<a href="https://baike.baidu.com/item/Safari" target="_blank" rel="noopener">Safari</a>浏览器使用的内核。 Webkit引擎包含WebCore<a href="https://baike.baidu.com/item/%E6%8E%92%E7%89%88%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">排版引擎</a>及JavaScriptCore解析引擎，均是从KDE的KHTML及KJS引擎衍生而来，它们都是自由软件，在GPL条约下授权，同时支持<a href="https://baike.baidu.com/item/BSD%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">BSD系统</a>的开发。所以<a href="https://baike.baidu.com/item/Webkit" target="_blank" rel="noopener">Webkit</a>也是自由软件，同时<a href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E6%BA%90%E4%BB%A3%E7%A0%81" target="_blank" rel="noopener">开放源代码</a>。在安全方面不受IE、Firefox的制约，所以Safari浏览器在国内还是很安全的。</p><p>Webkit浏览器：Chrome、Safari、Opera</p><h3 id="Trident"><a href="#Trident" class="headerlink" title="Trident"></a>Trident</h3><p>Trident(IE内核)：该内核程序在1997年的IE4中首次被采用，是微软在Mosaic代码的基础之上修改而来的，并沿用到IE11，也被普遍称作”IE内核”。Trident实际上是一款开放的内核，其接口内核设计的相当成熟，因此才有许多采用IE内核而非IE的浏览器(壳浏览器)涌现。</p><p>由于IE本身的“垄断性”（虽然名义上IE并非垄断，但实际上，特别是从Windows 95年代一直到XP初期，就市场占有率来说IE的确借助Windows的东风处于“垄断”的地位）而使得Trident内核的长期一家独大，微软很长时间都并没有更新Trident内核，这导致了两个后果——一是Trident内核曾经几乎与W3C标准脱节（2005年），二是Trident内核的大量 Bug等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为IE浏览器不安全的观点，也有很多用户转向了其他浏览器，<a href="https://baike.baidu.com/item/Firefox" target="_blank" rel="noopener">Firefox</a>和Opera就是这个时候兴起的。非Trident内核浏览器的市场占有率大幅提高也致使许多网页开发人员开始注意网页标准和非IE浏览器的浏览效果问题。</p><p>Trident内核的常见浏览器有<strong>：[1]  　</strong><a href="https://baike.baidu.com/item/IE6" target="_blank" rel="noopener">IE6</a>、<a href="https://baike.baidu.com/item/IE7" target="_blank" rel="noopener">IE7</a>、<a href="https://baike.baidu.com/item/IE8" target="_blank" rel="noopener">IE8</a>（Trident 4.0）、<a href="https://baike.baidu.com/item/IE9" target="_blank" rel="noopener">IE9</a>（Trident 5.0）、IE10（Trident 6.0）；<a href="https://baike.baidu.com/item/360%E5%AE%89%E5%85%A8%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">360安全浏览器</a>（1.0-5.0为Trident，6.0为Trident+Webkit，7.0为Trident+Blink）<a href="https://baike.baidu.com/item/%E7%8C%8E%E8%B1%B9%E6%9E%81%E8%BD%BB%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">猎豹极轻浏览器</a>，<a href="https://baike.baidu.com/item/360%E6%9E%81%E9%80%9F%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">360极速浏览器</a>（7.5之前为Trident+Webkit，7.5为Trident+Blink）<a href="https://baike.baidu.com/item/%E7%8C%8E%E8%B1%B9%E5%AE%89%E5%85%A8%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">猎豹安全浏览器</a>（1.0-4.2版本为Trident+Webkit，4.3及以后版本为Trident+Blink）<a href="https://baike.baidu.com/item/%E7%8C%8E%E8%B1%B9%E6%9E%81%E8%BD%BB%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">猎豹极轻浏览器</a>，傲游浏览器（傲游1.x、2.x为<a href="https://baike.baidu.com/item/IE" target="_blank" rel="noopener">IE</a>内核，3.x为IE与<a href="https://baike.baidu.com/item/Webkit" target="_blank" rel="noopener">Webkit</a>双核）、<a href="https://baike.baidu.com/item/%E7%99%BE%E5%BA%A6%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">百度浏览器</a>（早期版本）、<a href="https://baike.baidu.com/item/%E6%90%9C%E7%8B%97%E9%AB%98%E9%80%9F%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">搜狗高速浏览器</a>（1.x为Trident，2.0及以后版本为Trident+Webkit）、UC浏览器（Blink内核+Trident内核）等。</p><p>其中部分浏览器的新版本是“双核”甚至是“多核”，其中一个内核是Trident，然后再增加一个其他内核。国内的厂商一般把其他内核叫做“高速浏览模式”，而Trident则是“兼容浏览模式”，用户可以来回切换。</p><h3 id="Gecko"><a href="#Gecko" class="headerlink" title="Gecko"></a>Gecko</h3><p>Gecko(Firefox内核)：Netscape6开始采用的内核，后来的<a href="https://baike.baidu.com/item/Mozilla%20FireFox" target="_blank" rel="noopener">Mozilla FireFox</a>(<a href="https://baike.baidu.com/item/%E7%81%AB%E7%8B%90%E6%B5%8F%E8%A7%88%E5%99%A8" target="_blank" rel="noopener">火狐浏览器</a>) 也采用了该内核，Gecko的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko内核的浏览器也很多，这也是Gecko内核虽然年轻但市场占有率能够迅速提高的重要原因。</p><p>事实上，<a href="https://baike.baidu.com/item/Gecko%E5%BC%95%E6%93%8E" target="_blank" rel="noopener">Gecko引擎</a>的由来跟IE不无关系，前面说过IE没有使用<a href="https://baike.baidu.com/item/W3C" target="_blank" rel="noopener">W3C</a>的标准，这导致了微软内部一些开发人员的不满；他们与当时已经停止更新了的 Netscape的一些员工一起创办了Mozilla，以当时的Mosaic内核为基础重新编写内核，于是开发出了Gecko。不过事实上，Gecko 内核的浏览器仍然还是Firefox (<a href="https://baike.baidu.com/item/%E7%81%AB%E7%8B%90" target="_blank" rel="noopener">火狐</a>) 用户最多，所以有时也会被称为Firefox内核。此外Gecko也是一个跨平台内核，可以在Windows、 BSD、Linux和Mac OS X中使用。</p><p>补充：JavaScript引擎是SpiderMonkey。</p><p>Gecko内核常见的浏览器：[1]<a href> </a> <a href="https://baike.baidu.com/item/Mozilla%20Firefox" target="_blank" rel="noopener">Mozilla Firefox</a>、Mozilla SeaMonkey、waterfox（Firefox的64位开源版）、Iceweasel、Epiphany（早期版本）、Flock（早期版本）、K-Meleon</p><h3 id="Blink"><a href="#Blink" class="headerlink" title="Blink"></a>Blink</h3><p>Blink是一个由Google和Opera Software开发的浏览器排版引擎，Google计划将这个渲染引擎作为Chromium计划的一部分，并且在2013年4月的时候公布了这一消息。这一渲染引擎是开源引擎WebKit中WebCore组件的一个分支，并且在Chrome（28及往后版本）、Opera（15及往后版本）和Yandex浏览器中使用。</p><h3 id="EdgeHTML"><a href="#EdgeHTML" class="headerlink" title="EdgeHTML"></a>EdgeHTML</h3><p>EdgeHTML，是微软网页浏览器<a href="https://baike.baidu.com/item/Microsoft%20Edge" target="_blank" rel="noopener">Microsoft Edge</a>所使用的网页排版引擎(以下简称内核)的名称。由微软在原IE浏览器的<a href="https://baike.baidu.com/item/Trident/5795671" target="_blank" rel="noopener">Trident</a>内核基础上，删除了过时的旧技术支持代码，增加了对现代浏览器技术的支持，是一个全新的内核。初始版作为Windows 10 9926预览版的IE11内核，此后每一个Windows 10预览版的IE11和Project Spartan(Microsoft Edge尚未正式命名时的)都同时用EdgeHTML作为内核。</p><h3 id="Chromium"><a href="#Chromium" class="headerlink" title="Chromium"></a>Chromium</h3><p>Chromium是一个由Google主导开发的网页浏览器，以BSD许可证等多重自由版权发行并开放源代码。Chromium的开发可能早自2006年即开始，设计思想基于简单、高速、稳定、安全等理念，在架构上使用了苹果发展出来的WebKit排版引擎、Safari的部份源代码与Firefox的成果，并采用Google独家开发出的V8引擎以提升解译JavaScript的效率，而且设计了“沙盒”、“黑名单”、“无痕浏览”等功能来实现稳定与安全的网页浏览环境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天面试的时候面试官问到了关于浏览器内核的问题，当时他问的是有哪几种浏览器内核，但是我只知道WebKit一种，后来面试结束后一直想着这个问题，然后在网上了解了以下，下面是一些结果：&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端工具" scheme="https://langliu.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Python入门</title>
    <link href="https://langliu.github.io/2017/09/24/Python%E5%85%A5%E9%97%A8/"/>
    <id>https://langliu.github.io/2017/09/24/Python入门/</id>
    <published>2017-09-24T23:56:51.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>近两年Python很火，最近闲着没什么事干，于是也想学一下 Python，了解一门后端语言。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>学习一门语言，首先就要知道这门语言的优缺点及适用领域，只有了解了这些之后，才能更好地使用这门语言，那么下面就说一下Python的优缺点及适用领域：</p><a id="more"></a><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>代码简单、优雅</li><li>完善的基础代码库：Python为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>运行速度慢：因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。</li><li>代码不能加密</li></ul><h4 id="适用领域："><a href="#适用领域：" class="headerlink" title="适用领域："></a>适用领域：</h4><ul><li>网络应用，包括网站、后台服务等等</li><li>许多日常需要的小工具，包括系统管理员需要的脚本任务等等</li><li>把其他语言开发的程序再包装起来，方便使用</li></ul><h2 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Python的语法比较简单，采用缩进方式，写出来的代码就像下面的样子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print absolute value of an integer:</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">0</span>:</span><br><span class="line">    print(a)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(-a)</span><br></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>Python对代码的注释是以 <code>#</code> 为标志的语句，在Python代码执行的时候， <code>#</code> 后面的语句会自动忽略：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是注释</span></span><br><span class="line">name = <span class="string">'allen'</span>  <span class="comment"># 姓名</span></span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>因为Python采用缩进方式，所以不像其他语言那样按照 <code>{}</code> 内的内容算一个代码块，Python按不同的缩进分为不同的代码块，当语句以冒号<code>:</code>结尾时，缩进的语句视为代码块。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>Python是一门弱类型的语言，声明时不需要显示指定变量的类型，Python有以下基础类型：</p><ul><li>整数</li><li>浮点数</li><li>字符串<ul><li>在使用字符串的时候，有时候我们需要使用一些特殊的字符而不希望其被转义，这时我们可以使用 <code>r&#39;&#39;</code> 表示<code>&#39;&#39;</code>内部的字符串默认不转义</li><li>如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容</li></ul></li><li>布尔值 (True, False)<ul><li><code>and</code> 运算：<code>and</code>运算是与运算，只有所有都为<code>True</code>，<code>and</code>运算结果才是<code>True</code></li><li><code>or</code>运算：<code>or</code>运算是或运算，只要其中有一个为<code>True</code>，<code>or</code>运算结果就是<code>True</code></li><li><code>not</code>运算：<code>not</code>运算是非运算，它是一个单目运算符，把<code>True</code>变成<code>False</code>，<code>False</code>变成<code>True</code></li></ul></li><li>空值 (None)</li></ul><h3 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h3><ul><li>变量：变量以数字、字母和下划线组成，且不能以数字开头</li><li>常量：常量以全部大写的变量名表示</li></ul><h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>在Python中，有两种除法，一种除法是<code>/</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 / 3</span><br><span class="line">3.3333333333333335</span><br></pre></td></tr></table></figure><p><code>/</code>除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 9 / 3</span><br><span class="line">3.0</span><br></pre></td></tr></table></figure><p>还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 // 3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>你没有看错，整数的地板除<code>//</code>永远是整数，即使除不尽。要做精确的除法，使用<code>/</code>就可以。</p><h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>对于一门语言来说，输入和输出是最基础的语法，在很多地方都会用到：</p><h4 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h4><p>Python提供了一个从命令行获取输入的内置方法 <code>input(placeholder)</code> ，该方法有零个或一个参数，参数为用户输入的提示信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = input(<span class="string">'请输入姓名：'</span>)  <span class="comment"># 姓名</span></span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><p><code>print()</code> 方法可以用来输出，该方法可以接受一个或多个值，当接受多个值时每个值以 <code>,</code> 分隔，在输出的时候，遇见 <code>,</code> 则会将其转换为空格 </p><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>在最新的Python 3版本中，字符串是以Unicode编码的。对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'A'</span>)</span><br><span class="line"><span class="number">65</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'中'</span>)</span><br><span class="line"><span class="number">20013</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">66</span>)</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">25991</span>)</span><br><span class="line"><span class="string">'文'</span></span><br></pre></td></tr></table></figure><p>由于Python的字符串类型是<code>str</code>，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。</p><p>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">b'ABC'</span></span><br></pre></td></tr></table></figure><p>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</span><br><span class="line"><span class="string">b'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>我们经常会输出类似<code>&#39;亲爱的xxx你好！你xx月的话费是xx，余额是xx&#39;</code>之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。</p><p>常见的占位符有：</p><table><thead><tr><th>占位符</th><th>表示</th></tr></thead><tbody><tr><td>%d</td><td>整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td></tr></tbody></table><p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%2d-%02d'</span> % (<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="string">' 3-01'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%.2f'</span> % <span class="number">3.1415926</span></span><br><span class="line"><span class="string">'3.14'</span></span><br></pre></td></tr></table></figure><p>有些时候，字符串里面的<code>%</code>是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'所在专业排名： %d%%-%d%%'</span> % (<span class="number">5</span>, <span class="number">20</span>)</span><br><span class="line"><span class="string">'所在专业排名： 5%-20%'</span></span><br></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。（同其他语言的数组相似）</p><p>一个列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'allen'</span>, <span class="string">'jhon'</span>, <span class="string">'toy'</span>]</span><br></pre></td></tr></table></figure><h4 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h4><p>用索引来访问list中每一个位置的元素，索引从<code>0</code>开始，当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界。如果要从最后一个元素像前访问，可以以负数做索引，如最后一个元素的索引为<code>-1</code> ，倒数第二个元素的索引为 <code>-2</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names[<span class="number">1</span>]  <span class="comment"># allen</span></span><br><span class="line">names[<span class="number">-1</span>]  <span class="comment"># toy</span></span><br></pre></td></tr></table></figure><h4 id="添加元素到末尾"><a href="#添加元素到末尾" class="headerlink" title="添加元素到末尾"></a>添加元素到末尾</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.append(<span class="string">'young'</span>)</span><br></pre></td></tr></table></figure><h4 id="把元素插入到指定的位置"><a href="#把元素插入到指定的位置" class="headerlink" title="把元素插入到指定的位置"></a>把元素插入到指定的位置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.insert(<span class="number">1</span>, <span class="string">'Tom'</span>)</span><br></pre></td></tr></table></figure><h4 id="删除list末尾的元素"><a href="#删除list末尾的元素" class="headerlink" title="删除list末尾的元素"></a>删除list末尾的元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.pop()</span><br></pre></td></tr></table></figure><h4 id="删除指定位置的元素"><a href="#删除指定位置的元素" class="headerlink" title="删除指定位置的元素"></a>删除指定位置的元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.pop(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>tuple和list非常类似，但是tuple一旦初始化就不能修改，一个姓名的元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names = (<span class="string">'Allen'</span>, <span class="string">'Youngor'</span>)</span><br></pre></td></tr></table></figure><p>元组同样可以通过索引访问：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names[<span class="number">0</span>]  <span class="comment"># 'Allen'</span></span><br></pre></td></tr></table></figure><p>有一个地方需要注意，如果你想创建一个只有一个元素的元组，那么在定义的时候需要小心，你应该这么定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = (<span class="string">'Allen'</span>,)</span><br></pre></td></tr></table></figure><p>注意最后的逗号，如果没有逗号的话就不是一个元组了，Python会将其进行运算，转换成一个字符串</p><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> &lt;条件判断<span class="number">1</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">2</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">2</span>&gt;</span><br><span class="line"><span class="keyword">elif</span> &lt;条件判断<span class="number">3</span>&gt;:</span><br><span class="line">    &lt;执行<span class="number">3</span>&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;执行<span class="number">4</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="for…in循环"><a href="#for…in循环" class="headerlink" title="for…in循环"></a>for…in循环</h4><p>for…in循环，依次把list或tuple中的每个元素迭代出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Michael'</span>, <span class="string">'Bob'</span>, <span class="string">'Tracy'</span>]</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p>如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个<code>range()</code>函数，可以生成一个整数序列，再通过<code>list()</code>函数可以转换为list。比如<code>range(5)</code>生成的序列是从0开始小于5的整数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(range(<span class="number">5</span>))  <span class="comment"># [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>while循环，只要条件满足，就不断循环，条件不满足时退出循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> n &lt;= <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">10</span>: <span class="comment"># 当n = 11时，条件满足，执行break语句</span></span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># break语句会结束当前循环</span></span><br><span class="line">    print(n)</span><br><span class="line">    n = n + <span class="number">1</span></span><br><span class="line">print(<span class="string">'END'</span>)</span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p><p>一个姓名-成绩的字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'Michael'</span>: <span class="number">95</span>, <span class="string">'Bob'</span>: <span class="number">75</span>, <span class="string">'Tracy'</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure><p>如果key不存在，dict就会报错，有两种方式可以判断key是否存在：</p><ul><li><code>in</code> ：<code>&#39;Bob&#39; in d</code></li><li><code>get(key, default)</code> ：如果key不存在，可以返回None，或者自己指定的value</li></ul><h4 id="删除一个key："><a href="#删除一个key：" class="headerlink" title="删除一个key："></a>删除一个key：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d.pop(<span class="string">'Bob)</span></span><br></pre></td></tr></table></figure><p>和list比较，dict有以下几个特点：</p><ol><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多。</li></ol><p>而list相反：</p><ol><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少。</li></ol><p>所以，dict是用空间来换取时间的一种方法。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p><p>一个set：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">'Allen'</span>, <span class="string">'Youngor'</span>]</span><br><span class="line">s = set(names)  <span class="comment"># &#123;'Allen', 'Youngor'&#125;</span></span><br></pre></td></tr></table></figure><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.add(<span class="string">'John'</span>)  <span class="comment"># &#123;'Allen', 'Youngor', 'John'&#125;</span></span><br></pre></td></tr></table></figure><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.remove(<span class="string">'Allen'</span>)  <span class="comment"># &#123;'Youngor', 'John'&#125;</span></span><br></pre></td></tr></table></figure><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 - s2</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><ul><li>int()</li><li>str()</li><li>float()</li><li>bool()</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><p>在Python中，定义一个函数要使用<code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号<code>:</code>，然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。</p><p>一个求绝对值的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_abs</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br></pre></td></tr></table></figure><h4 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h4><p>如果想定义一个什么事也不做的空函数，可以用<code>pass</code>语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="参数检查"><a href="#参数检查" class="headerlink" title="参数检查"></a>参数检查</h4><p>调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出<code>TypeError</code></p><h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h4><p>函数可以返回多个值吗？答案是肯定的。</p><p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(x, y, step, angle=<span class="number">0</span>)</span>:</span></span><br><span class="line">    nx = x + step * math.cos(angle)</span><br><span class="line">    ny = y - step * math.sin(angle)</span><br><span class="line">    <span class="keyword">return</span> nx, ny</span><br></pre></td></tr></table></figure><p><code>import math</code>语句表示导入<code>math</code>包，并允许后续代码引用<code>math</code>包里的<code>sin</code>、<code>cos</code>等函数。</p><p>然后，我们就可以同时获得返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y = move(<span class="number">100</span>, <span class="number">100</span>, <span class="number">60</span>, math.pi / <span class="number">6</span>)</span><br></pre></td></tr></table></figure><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow</span><span class="params">(n, m=<span class="number">2</span>, age=<span class="number">22</span>)</span>:</span></span><br><span class="line">  print(<span class="string">'age: %d'</span> % age)</span><br><span class="line"><span class="keyword">return</span> n + m</span><br></pre></td></tr></table></figure><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pow(<span class="number">3</span>)  <span class="comment"># 5</span></span><br><span class="line">pow(<span class="number">3</span>, <span class="number">6</span>)  <span class="comment"># 9</span></span><br><span class="line">pow(<span class="number">3</span>, age=<span class="number">34</span>)  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    print(numbers[<span class="number">0</span>])</span><br><span class="line">    print(numbers[<span class="number">1</span>])</span><br><span class="line">    print(numbers[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        s += n * n</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = calc(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近两年Python很火，最近闲着没什么事干，于是也想学一下 Python，了解一门后端语言。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;优缺点&quot;&gt;&lt;a href=&quot;#优缺点&quot; class=&quot;headerlink&quot; title=&quot;优缺点&quot;&gt;&lt;/a&gt;优缺点&lt;/h3&gt;&lt;p&gt;学习一门语言，首先就要知道这门语言的优缺点及适用领域，只有了解了这些之后，才能更好地使用这门语言，那么下面就说一下Python的优缺点及适用领域：&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="https://langliu.github.io/categories/Python/"/>
    
    
      <category term="Python语法" scheme="https://langliu.github.io/tags/Python%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Ajax技术</title>
    <link href="https://langliu.github.io/2017/09/22/Ajax%E6%8A%80%E6%9C%AF/"/>
    <id>https://langliu.github.io/2017/09/22/Ajax技术/</id>
    <published>2017-09-22T22:27:20.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Ajax？"><a href="#什么是Ajax？" class="headerlink" title="什么是Ajax？"></a>什么是Ajax？</h2><p>AJAX = 异步 JavaScript 和 XML。</p><p>AJAX 是一种用于创建快速动态网页的技术。</p><p>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><a id="more"></a><h3 id="一个简单的Ajax请求"><a href="#一个简单的Ajax请求" class="headerlink" title="一个简单的Ajax请求"></a>一个简单的Ajax请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'data.json'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h2><p>XMLHttpRequest 是 AJAX 的基础。所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。</p><ul><li>现代浏览器：<code>const xhr = new XMLHttpRequest();</code></li><li>IE5和IE6：<code>const xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Old compatibility code, no longer needed.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123; <span class="comment">// Mozilla, Safari, IE7+ ...</span></span><br><span class="line">    httpRequest = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123; <span class="comment">// IE 6 and older</span></span><br><span class="line">    httpRequest = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XMLHttpRequest-的用法"><a href="#XMLHttpRequest-的用法" class="headerlink" title="XMLHttpRequest 的用法"></a>XMLHttpRequest 的用法</h2><h3 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h3><p>在使用 XMLHttpRequest 对象的时候，要调用的第一个方法就是 <code>open(method, url, async)</code> ，该方法接受三个参数：</p><ul><li>method：要发送的请求的类型 // “get”、”post” 等</li><li>url：请求的URL（请求的url中如果有中文会报错，所以如果要使用中文要对参数重新使用 <code>encodeURI()</code> 编码）</li><li>async：是否异步发送请求的布尔值</li></ul><h3 id="setRequestHeader"><a href="#setRequestHeader" class="headerlink" title="setRequestHeader()"></a>setRequestHeader()</h3><p><code>setRequestHeader(header, value)</code> 用于设置请求头</p><h3 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h3><p><code>send(message)</code> 方法接受一个参数，即要作为请求主体发送的数据。如果是 <code>get</code> 方法，则不发送数据。</p><h3 id="获取传回的数据"><a href="#获取传回的数据" class="headerlink" title="获取传回的数据"></a>获取传回的数据</h3><p>要获取返回的数据要知道请求现在处于什么状态，可以使用 <code>onreadystatechange</code> 来监听请求状态的变化，然后通过检测 <code>readyState</code> 属性的值来判断请求现在的状态</p><p><code>readyState</code> 属性有5个值：</p><ul><li>0：XMLHttpRequest对象创建完成</li><li>1：XMLHttpRequest对象初始化完成</li><li>2：请求已经发送</li><li>3：服务器已经返回了数据（数据还未被解析，可能只是一段http报文）</li><li>4：数据解析已经完成</li></ul><h3 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h3><p><code>XMLHttpRequest</code> 提供了各种在请求被处理期间发生的事件以供监听。这包括定期进度通知、 错误通知，等等。</p><ul><li>loadstart：在接收到响应数据的第一个字节时触发</li><li>progress：在收到响应期间持续不断地触发</li><li>error：在请求发生错误时触发</li><li>abort：在因为调用abort方法而中断请求时触发</li><li>onload：在接收到完整的响应数据时触发</li><li>loadend：在通信完成或触发error、abort、或load事件后触发</li></ul><p>使用进度事件可以代替 <code>onreadystatechange</code> 来监听请求状态的变化，例如上面的例子我们可以改写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'data.json'</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br><span class="line">xhr.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h3><p>当请求信息发送之后，请求就会被分派到服务器。在服务器响应后，会将响应数据自动填充到XHR对象的属性中，相关属性如下：</p><ul><li><code>responseText</code> ：作为响应主体被返回的文本（JSON格式）</li><li><code>responseXML</code> ：如果响应的内容类型是 <code>text/xml</code> 或 <code>application/xml</code> ，这个属性中将保存着响应数据的XML DOM文档（XML格式）</li><li><code>status</code> ：响应的HTTP状态（200：成功；404：页面不存在；503：页面存在，但有语法错误）</li><li><code>statusText</code> ：HTTP状态的说明</li></ul><h2 id="GET-还是-POST？"><a href="#GET-还是-POST？" class="headerlink" title="GET 还是 POST？"></a>GET 还是 POST？</h2><p>与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。</p><p>然而，在以下情况中，请使用 POST 请求：</p><ul><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul><h3 id="GET-和-POST-的差别"><a href="#GET-和-POST-的差别" class="headerlink" title="GET 和 POST 的差别"></a>GET 和 POST 的差别</h3><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h4><ul><li>将表单数据以名/值对的形式附加到URL中（数据是可见的，不能用于提交敏感数据）</li><li>URL的长度是有限的（大约3000字符）</li><li>GET请求会被浏览器主动缓存</li><li>GET产生一个TCP数据包（对于GET方式的请求，浏览器会把HTTP header 和 data 一并发送出去，服务器响应200）</li></ul><h4 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h4><ul><li>将表单数据附加到HTTP请求的body内</li><li>没有长度限制</li><li>POST请求不会被浏览器主动缓存</li><li>通过POST请求提交的表单不能加入书签</li><li>POST产生两个TCP数据包（对于POST方式的请求，浏览器先发送HTTP header，服务器响应100， 浏览器再发送data，服务器响应200）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Ajax？&quot;&gt;&lt;a href=&quot;#什么是Ajax？&quot; class=&quot;headerlink&quot; title=&quot;什么是Ajax？&quot;&gt;&lt;/a&gt;什么是Ajax？&lt;/h2&gt;&lt;p&gt;AJAX = 异步 JavaScript 和 XML。&lt;/p&gt;
&lt;p&gt;AJAX 是一种用于创建快速动态网页的技术。&lt;/p&gt;
&lt;p&gt;通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://langliu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Jasmine——行为驱动开发</title>
    <link href="https://langliu.github.io/2017/09/18/Jasmine%E2%80%94%E2%80%94%E8%A1%8C%E4%B8%BA%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    <id>https://langliu.github.io/2017/09/18/Jasmine——行为驱动开发/</id>
    <published>2017-09-18T21:39:25.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>Jasmine是测试 JavaScript 代码行为驱动开发框架。它并不取决于任何其他 JavaScript 框架。它不需要 dom。它有清洁、 明显的语法，使您可以轻松编写测试。</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install jasmine --save-dev // 安装到项目</span><br><span class="line"></span><br><span class="line">npm install jasmine --global // 全局安装</span><br></pre></td></tr></table></figure><h3 id="初始化一个项目"><a href="#初始化一个项目" class="headerlink" title="初始化一个项目"></a>初始化一个项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/jasmine</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "spec_dir": "spec", // spec所在目录</span><br><span class="line">  "spec_files": [</span><br><span class="line">    "**/*[sS]pec.js" // 测试文件（以[sS]pec.js结尾的js文件，可以自己更改后缀名）</span><br><span class="line">  ],</span><br><span class="line">  "helpers": [</span><br><span class="line">    "helpers/**/*.js" // 测试前辅助文件，相对于spec_dir</span><br><span class="line">  ],</span><br><span class="line">  "stopSpecOnExpectationFailure": false,</span><br><span class="line">  "random": false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jasmine // 根据配置运行所有的测试</span><br><span class="line"></span><br><span class="line">jasmine spec/test.spec.js // 运行某个测试</span><br></pre></td></tr></table></figure><h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><p>上面我们已经成功将Jasmine安装到我们的项目中了，现在我们可以开始编写单元测试的代码了</p><p>一个最基本的单元测试代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"A suite"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">"contains spec with an expectation"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    expect(<span class="literal">true</span>).toBe(<span class="literal">true</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>每个测试都在一个测试集中运行，Suite就是一个测试集，用describe函数封装。 Spec表示每个测试用例，用it函数封装。通过expect函数，作为程序断言来判断相等关系。</p><p><code>describe</code> 函数包含两个参数：</p><ul><li><code>string</code> name 一个测试套件的名称</li><li><code>function</code> fn 实现测试套件的代码块</li></ul><p><code>it</code> 函数定义两个参数：</p><ul><li><code>string</code> name spec的标题</li><li><code>function</code> fn spec的函数</li></ul><p><code>expect</code> 函数 接收一个 <code>value</code> , 返回一个链式匹配对象<br>拥有以下匹配规则函数：</p><ul><li>toBe // 引用全等 ‘===’</li><li>toEqual // 深度遍历，值全等</li><li>toMatch // 正则匹配，支持字符串和正则表达式</li><li>toContain // 判断字符串或数组中是否包含某个字符或元素</li><li>toBeNull // === null</li><li>toBeDefined // expect !== undefined</li><li>toBeUndefined // expect === undefined</li><li>toBeTruthy // Boolean(expect) === true</li><li>toBeFalsy // Boolean(expect) === false</li><li>toBeLessThan // expect的参数小于 &lt; value；expect(2).toBeLessThan(3);</li><li>toBeGreaterThan // expect的参数大于 &gt; value</li><li>toBeCloseTo // value - precision &lt;= expect &lt; value + precision；expect(3.1415926).toBeCloseTo(2.78, 0);</li><li>toThrow // expect throw ‘xx’</li><li>toThrowError // expect throw type or match error message</li></ul><p><strong>一个suite 可以有多个 describe, 一个 describe 可以有多个 it, 一个it 可以有多个 expect</strong></p><h3 id="fail函数"><a href="#fail函数" class="headerlink" title="fail函数"></a>fail函数</h3><p><code>fail</code> 函数, 直接指定spec的错误原因：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"A suite is just a function"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">    it(<span class="string">"and so is a spec"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        a = <span class="literal">true</span>;</span><br><span class="line">        expect(<span class="number">1</span>).toBe(<span class="string">'1'</span>);</span><br><span class="line">        fail(<span class="string">'两个值并不全等'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在上面的测试代码中，通过fail函数将测试不通过的原因指定为我们自定义的信息，如果为添加 <code>fail</code> 函数，Jasmine将会使用框架提供的提示，像下面这样： <code>Expected 1 to be &#39;1&#39;.</code>；而如果使用了 <code>fail</code> 函数，错误的提示信息将会变为： <code>两个值并不全等</code></p><h3 id="not"><a href="#not" class="headerlink" title="not"></a>not</h3><p>任何匹配表达式都可以有 <code>not</code> 前缀对象， 表示与期待的相反. 如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'a suite'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'should not equal false if expect is true'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(<span class="literal">true</span>).not.toBe(<span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="挂起的测试"><a href="#挂起的测试" class="headerlink" title="挂起的测试"></a>挂起的测试</h3><p>如果我们写了某个测试规则，但不想让这个测试跑的话，我们有三种方式可以实现：</p><ul><li>需要将该规则的声明关键字变为 <code>xit</code> ，这样该测试规则在测试运行的时候就会被忽略。</li><li>使用 <code>it</code> 声明，但是没有函数体</li><li>在规则内部使用 <code>pending()</code> 声明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Pending specs"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    xit(<span class="string">"can be declared 'xit'"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(<span class="literal">true</span>).toBe(<span class="literal">false</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    it(<span class="string">"can be declared with 'it' but without a function"</span>);</span><br><span class="line">    it(<span class="string">"can be declared by calling 'pending' in the spec body"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(<span class="literal">true</span>).toBe(<span class="literal">false</span>);</span><br><span class="line">        pending(<span class="string">'this is why it is pending'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>更多的内容可以参考Jasmine的官方说明： <a href="https://jasmine.github.io/edge/introduction.html" target="_blank" rel="noopener">https://jasmine.github.io/edge/introduction.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jasmine是测试 JavaScript 代码行为驱动开发框架。它并不取决于任何其他 JavaScript 框架。它不需要 dom。它有清洁、 明显的语法，使您可以轻松编写测试。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端工具" scheme="https://langliu.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Babel的使用</title>
    <link href="https://langliu.github.io/2017/09/17/Babel%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://langliu.github.io/2017/09/17/Babel的使用/</id>
    <published>2017-09-17T15:35:09.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>ES2015出来已经有好几年了，但是到今天为止，所有的ES2015的语法并没有被全部支持，那么ES2015的语法是不是就不能使用不支持的那些呢？不是的，我们完全可以在我们的代码里面使用所有的ES2015的语法，只要我们配置了Babel。</p><a id="more"></a><h2 id="bable-cli"><a href="#bable-cli" class="headerlink" title="bable-cli"></a>bable-cli</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-cli</span><br></pre></td></tr></table></figure><h3 id="编译单个文件"><a href="#编译单个文件" class="headerlink" title="编译单个文件"></a>编译单个文件</h3><p>如果你想编译某个文件并且输出编译后的结果到另一个文件，我们可以使用 <code>--out-file</code> 或者 <code>-o</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel script.js --out-file script-compiled.js</span><br></pre></td></tr></table></figure><p>如果每次改变文件都想它自动编译并输出，我们需要在编译的时候添加 <code>--watch</code> 或者 <code>-w</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel script.js --watch --out-file script-compiled.js</span><br></pre></td></tr></table></figure><h3 id="编译整个目录中的文件"><a href="#编译整个目录中的文件" class="headerlink" title="编译整个目录中的文件"></a>编译整个目录中的文件</h3><p>对于写项目来说，如果文件需要一个一个的编译那么太麻烦了，有可能一个项目中有成百上千个文件，这时我们就需要使用Babel提供的按文件夹编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel src --out-dir lib</span><br></pre></td></tr></table></figure><p>执行上面的命令后，babel会将src文件夹下面的所有文件按照目录结构编译到lib文件夹下，你可以在lib文件夹中看见和src文件夹中一样的目录结构，只不过lib文件夹下的所以文件都是编译后的结果。</p><p>将整个目录的文件输出到一个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel src --out-file script-compiled.js</span><br></pre></td></tr></table></figure><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>有时候在我们的代码中有一些测试文件或其他的文件我们并不需要编译，那么这时候我们就可以使用 <code>--ignore + &lt;filename&gt;</code> 来忽略这些文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel src --out-dir lib --ignore spec.js,test.js</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们就忽略了src文件夹下的以spec.js和test.js结尾的文件，比如main.spec.js、main.test.js，当然如果你的文件夹下有spec.js和test.js这两个文件，babel也会将其忽略。</p><h3 id="babel-node"><a href="#babel-node" class="headerlink" title="babel-node"></a>babel-node</h3><p>我们运行js的时候使用的命令是 <code>node &lt;filename&gt;</code> ，如果你的js代码中使用了nodejs暂时还未支持的语法，则代码会报错。这时，Babel提供给我们了一个 <code>babel-node</code> 命令，你可使用 <code>babel-node</code> 命令替换 <code>node</code> 命令直接运行ES2015的代码，而不需要将其编译成ES5的语法后运行编译后的代码。</p><h2 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h2><p>Babel的配置文件是.babelrc，存放在项目的根目录下。该文件用来设置转码规则和插件，基本格式如下。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [],</span><br><span class="line">  <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ES2015+转码规则</span></span><br><span class="line">$ npm install babel-preset-env --save-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># react转码规则</span></span><br><span class="line">$ npm install --save-dev babel-preset-react</span><br></pre></td></tr></table></figure><p>安装了你所需要的转码规则之后，将其添加到 <code>.babelrc</code> 文件中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    <span class="string">"env"</span>,</span><br><span class="line">    <span class="string">"react"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过webpack使用Babel"><a href="#通过webpack使用Babel" class="headerlink" title="通过webpack使用Babel"></a>通过webpack使用Babel</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader babel-core</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建-babelrc配置文件"><a href="#创建-babelrc配置文件" class="headerlink" title="创建.babelrc配置文件"></a>创建.babelrc配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-preset-env --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES2015出来已经有好几年了，但是到今天为止，所有的ES2015的语法并没有被全部支持，那么ES2015的语法是不是就不能使用不支持的那些呢？不是的，我们完全可以在我们的代码里面使用所有的ES2015的语法，只要我们配置了Babel。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端工具" scheme="https://langliu.github.io/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>ES2015关于类的概念</title>
    <link href="https://langliu.github.io/2017/09/16/ES2015%E5%85%B3%E4%BA%8E%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>https://langliu.github.io/2017/09/16/ES2015关于类的概念/</id>
    <published>2017-09-16T00:02:41.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>最近又复习了一下原型和原型链的知识，对比ES2015中的类，突然感觉原型链好麻烦，许多语法都不够简洁。</p><p>如果使用ES2015中的Class定义类像是下面这样的：</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, sex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toString() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, sex: <span class="subst">$&#123;<span class="keyword">this</span>.sex&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用ES5的语法则是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, sex</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>, sex: <span class="subst">$&#123;<span class="keyword">this</span>.sex&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ES6 的类，完全可以看作构造函数的另一种写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p><h3 id="Class表达式"><a href="#Class表达式" class="headerlink" title="Class表达式"></a>Class表达式</h3><p>与函数一样，类也可以使用表达式的形式定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Me.getClassName(); <span class="comment">//  ReferenceError: Me is not defined</span></span><br></pre></td></tr></table></figure><h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><p>由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;&#125;</span><br><span class="line">Point.name <span class="comment">// "Point"</span></span><br></pre></td></tr></table></figure><p>name属性总是返回紧跟在class关键字后面的类名。</p><h3 id="Class-的取值函数（getter）和存值函数（setter）"><a href="#Class-的取值函数（getter）和存值函数（setter）" class="headerlink" title="Class 的取值函数（getter）和存值函数（setter）"></a>Class 的取值函数（getter）和存值函数（setter）</h3><p>与 ES5 一样，在”类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name, sex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> setName(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Class的静态方法"><a href="#Class的静态方法" class="headerlink" title="Class的静态方法"></a>Class的静态方法</h3><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为”静态方法”。</p><p><strong>如果静态方法包含this关键字，这个this指的是类，而不是实例。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure><h3 id="new-target属性"><a href="#new-target属性" class="headerlink" title="new.target属性"></a>new.target属性</h3><p>ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p><p>Class 内部调用new.target，返回当前 Class。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure><p>需要注意的是，子类继承父类时，new.target会返回子类。</p><h2 id="Class-的继承"><a href="#Class-的继承" class="headerlink" title="Class 的继承"></a>Class 的继承</h2><p>Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。子类必须在constructor方法中调用super方法，否则新建实例时会报错。</p><p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。如果像下面这样就会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.color = color; <span class="comment">// Error</span></span><br><span class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个类是否继承了另一个类"><a href="#判断一个类是否继承了另一个类" class="headerlink" title="判断一个类是否继承了另一个类"></a>判断一个类是否继承了另一个类</h3><p>Object.getPrototypeOf方法可以用来从子类上获取父类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint) === Point; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p><code>super</code> 这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</p><p>第一种情况， <code>super</code> 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 <code>super</code> 函数。</p><p>第二种情况， <code>super</code> 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p><p>ES6 规定，通过super调用父类的方法时，super会绑定子类的this。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    <span class="keyword">super</span>.print();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line">b.m() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;最近又复习了一下原型和原型链的知识，对比ES2015中的类，突然感觉原型链好麻烦，许多语法都不够简洁。&lt;/p&gt;
&lt;p&gt;如果使用ES2015中的Class定义类像是下面这样的：&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://langliu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JSON格式</title>
    <link href="https://langliu.github.io/2017/09/14/JSON%E6%A0%BC%E5%BC%8F/"/>
    <id>https://langliu.github.io/2017/09/14/JSON格式/</id>
    <published>2017-09-14T23:26:50.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<p>JSON的全称是“JavaScript Object Notation”，意思是JavaScript对象表示法。它是一种基于文本，独立于语言的轻量级数据交换格式。</p><a id="more"></a><p>JSON构建于两种数据结构：</p><ul><li>“名称：值”对的集合</li><li>值的有序列表（数组）</li></ul><p>JSON的值可以是：</p><ul><li>数字</li><li>字符串（<strong>JSON的字符串必须使用双引号</strong>）</li><li>布尔值</li><li>数组</li><li>对象</li><li>null</li></ul><h3 id="在JavaScript中使用JSON"><a href="#在JavaScript中使用JSON" class="headerlink" title="在JavaScript中使用JSON"></a>在JavaScript中使用JSON</h3><h4 id="将JSON对象转换成字符串——JSON-stringify"><a href="#将JSON对象转换成字符串——JSON-stringify" class="headerlink" title="将JSON对象转换成字符串——JSON.stringify()"></a>将JSON对象转换成字符串——JSON.stringify()</h4><p><code>JSON.stringify()</code> 方法将一个JavaScript值转换为一个 <code>JSON</code> 字符串，如果指定了一个 <code>replacer</code> 函数，则可以替换值，或者如果指定了一个 <code>replacer</code> 数组，可选地仅包括指定的属性。</p><p><code>JSON.stringify()</code> 方法接收三个参数：</p><ul><li>第一个参数JavaScript对象</li><li>第二个参数为一个数组或一个函数<ul><li>如果参数为数组，那么 <code>JSON.stringify()</code> 的结果中将只包含数组中列出的属性</li><li>如果参数为函数，该函数接收两个参数：一个键和一个值，对传入的对象进行操作，如果该函数返回 <code>undefined</code> ，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。</li></ul></li><li>第三个参数为字符串缩进的空格数（不超过10）</li></ul><h4 id="将字符串转换成JSON对象——JSON-parse"><a href="#将字符串转换成JSON对象——JSON-parse" class="headerlink" title="将字符串转换成JSON对象——JSON.parse()"></a>将字符串转换成JSON对象——JSON.parse()</h4><p><code>JSON.parse()</code> 方法接收两个参数，第一个参数是要解析的JSON字符串，第二个参数是一个函数，该函数接收两个参数：一个键和一个值，对传入的JSON字符串进行操作，如果该函数返回 <code>undefined</code> ，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。</p><p>若被解析的 <code>JSON</code> 字符串是非法的，则会抛出一个语法错误异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSON的全称是“JavaScript Object Notation”，意思是JavaScript对象表示法。它是一种基于文本，独立于语言的轻量级数据交换格式。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://langliu.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Angular路由</title>
    <link href="https://langliu.github.io/2017/06/22/%E8%B7%AF%E7%94%B1/"/>
    <id>https://langliu.github.io/2017/06/22/路由/</id>
    <published>2017-06-22T15:53:40.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么需要路由"><a href="#为什么需要路由" class="headerlink" title="为什么需要路由"></a>为什么需要路由</h1><p>在应用程序中定义路由非常有用，因为我们可以：</p><ul><li>将应用程序划分为多个分区</li><li>维护应用程序的状态</li><li>基于某些规则保护应用分区</li></ul><p>使用路由能使我们定义URL字符串，指定用户在应用中的位置。</p><a id="more"></a><h1 id="客户端路由的工作原理"><a href="#客户端路由的工作原理" class="headerlink" title="客户端路由的工作原理"></a>客户端路由的工作原理</h1><p>Angular应用是单页面应用程序，服务器只提供一个页面，负责渲染各种页面的是Javascript。</p><h2 id="使用锚标记"><a href="#使用锚标记" class="headerlink" title="使用锚标记"></a>使用锚标记</h2><p>单页面应用程序客户端框架使用的方式是：将锚标记作为路径来格式化，用它们代表应用程序的路由。</p><h2 id="HTML5客户端路由"><a href="#HTML5客户端路由" class="headerlink" title="HTML5客户端路由"></a>HTML5客户端路由</h2><p>随着HTML5的引入，浏览器获得了新的能力：在不需要新请求的情况下，允许在代码中创建新的浏览器记录项并显示适当的URL。</p><p>在Angular中，HTML5路由是默认的模式。</p><h1 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h1><p>我们使用三种主要部件来配置Angular路由：</p><ul><li>Routes：描述了应用程序支持的路由配置</li><li>RouterOutlet：这是一个”占位符”组件，用于告诉Angular要把每个路由的内容放在哪里</li><li>RouteLink：用于创建各种路由链接</li></ul><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>为了使用Angular的路由器，首先从@angular/router库中导入一些常量。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; RouterModule, Routes &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br></pre></td></tr></table></figure><h2 id="路由配置-1"><a href="#路由配置-1" class="headerlink" title="路由配置"></a>路由配置</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'home'</span>,</span><br><span class="line">    component: HomeComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'about'</span>,</span><br><span class="line">    component: AboutComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">''</span>,</span><br><span class="line">    redirectTo: <span class="string">'home'</span>,</span><br><span class="line">    pathMatch: <span class="string">'full'</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li>path：指定了该路由要处理的URL路径</li><li>component：用于连接当前路由路径与处理该路由的组件</li><li>redirectTo：一个可选选项，用于将当前路径重定向到另一个已知路由</li></ul><h2 id="安装路由配置"><a href="#安装路由配置" class="headerlink" title="安装路由配置"></a>安装路由配置</h2><p>在NgModule中的imports数组里使用RouterModule.forRoot(routes)来安装路由配置。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">imports: [</span><br><span class="line">  BrowserModule,</span><br><span class="line">  RouterModule.forRoot(routes) <span class="comment">// &lt;-- routes</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="使用-lt-router-outlet-gt-调用RouterOutlet指令"><a href="#使用-lt-router-outlet-gt-调用RouterOutlet指令" class="headerlink" title="使用&lt;router-outlet&gt;调用RouterOutlet指令"></a>使用<code>&lt;router-outlet&gt;</code>调用RouterOutlet指令</h2><p>将<code>&lt;router-outlet&gt;&lt;/router-outlet&gt;</code>放在你需要渲染组件的地方，当你路由到该组件时，该指令会替换为该路由的组件。</p><h2 id="使用-routerLink-调用routerLink指令"><a href="#使用-routerLink-调用routerLink指令" class="headerlink" title="使用[routerLink]调用routerLink指令"></a>使用[routerLink]调用routerLink指令</h2><p>在不重载页面的情况下链接路由，我们需要使用routerLink指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> [<span class="attr">routerLink</span>]=<span class="string">"['home']"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> [<span class="attr">routerLink</span>]=<span class="string">"['about']"</span>&gt;</span>About<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用[routerLink]将指示Angular获得click事件的所有权，然后基于路由的定义，初始化路由并导航到正确的位置。</p><h1 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h1><p>定位策略是Angular应用从路由定义进行解析和创建路径的方式。</p><p>Angular的默认策略为PathLocationStrategy，也就是HTML5路由。在使用这个策略时，路由的路径是常规路径，例如/home或者/about。</p><p>使用HTML5路由时，如果刷新页面，我们向服务器索要的就不是服务器提供的根URL，而是/home或者/about。因为服务器端没有对应的/home或者/about页面，所以它会返回404。</p><p>而使用锚点标记策略时，例如/#/home或者/#/about时，服务器将它们解析为/路径。刷新页面时，则会找到正确的页面。</p><h2 id="使用锚点标记策略"><a href="#使用锚点标记策略" class="headerlink" title="使用锚点标记策略"></a>使用锚点标记策略</h2><h3 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; LocationStrategy, HashLocationStrategy &#125; <span class="keyword">from</span> <span class="string">'@angular/common'</span>;</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">providers: [</span><br><span class="line">  &#123; provide: LocationStrategy, useClass: HashLocationStrategy &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h1><p>有时候，我们需要在一个应用程序中导航到特定的页面。比如说一个购物网站，我们需要从首页的商品中点击一个商品进入它的详情页，那么我们可能会使用以下这种URL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/productdetail/1</span><br></pre></td></tr></table></figure><p>很显然，这么多商品我们不可能给每一个商品都写一个路由，这时候，我们就需要使用路由参数。</p><h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p>我们需要在路径前加一个冒号，设定路由接收一个参数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes: Routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'home'</span>,</span><br><span class="line">    component: HomeComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'productdetail/:id'</span>,</span><br><span class="line">    component: ProductDetailComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">''</span>,</span><br><span class="line">    redirectTo: <span class="string">'home'</span>,</span><br><span class="line">    pathMatch: <span class="string">'full'</span></span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>为了使用路由参数，我们首先需要导入ActivatedRoute：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ActivatedRoute &#125; <span class="keyword">from</span> <span class="string">'@angular/router'</span>;</span><br></pre></td></tr></table></figure><p>接下来，我们需要将ActivatedRoute注入组件的构造函数中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ProductDetailComponent &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> route: ActivatedRoute</span>) &#123;</span><br><span class="line">    route.params.subscribe(<span class="function"><span class="params">params</span> =&gt;</span> &#123; <span class="keyword">this</span>.id = params[<span class="string">'id'</span>]; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么需要路由&quot;&gt;&lt;a href=&quot;#为什么需要路由&quot; class=&quot;headerlink&quot; title=&quot;为什么需要路由&quot;&gt;&lt;/a&gt;为什么需要路由&lt;/h1&gt;&lt;p&gt;在应用程序中定义路由非常有用，因为我们可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将应用程序划分为多个分区&lt;/li&gt;
&lt;li&gt;维护应用程序的状态&lt;/li&gt;
&lt;li&gt;基于某些规则保护应用分区&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用路由能使我们定义URL字符串，指定用户在应用中的位置。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Angular" scheme="https://langliu.github.io/tags/Angular/"/>
    
  </entry>
  
  <entry>
    <title>图片垂直居中</title>
    <link href="https://langliu.github.io/2017/06/21/%E5%9B%BE%E7%89%87%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <id>https://langliu.github.io/2017/06/21/图片垂直居中/</id>
    <published>2017-06-21T23:53:40.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图片垂直居中"><a href="#图片垂直居中" class="headerlink" title="图片垂直居中"></a>图片垂直居中</h1><p>在写项目的时候，我想让一张图片垂直居中，可是又不知道怎么做，于是在网上找了一些方案，一下的方法都经过我自己的试验，在我的代码中是能够实现图片垂直居中的效果的</p><a id="more"></a><h2 id="利用display-table-cell"><a href="#利用display-table-cell" class="headerlink" title="利用display:table-cell"></a>利用display:table-cell</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背景法"><a href="#背景法" class="headerlink" title="背景法"></a>背景法</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">background</span>: url(<span class="string">/assets/images/068a74df58cae466fb7c6d173ce75d9a0b60ac081f807-r0XXgn.jpg</span>) center no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片外面用个p标签，通过设置line-height使图片垂直居中"><a href="#图片外面用个p标签，通过设置line-height使图片垂直居中" class="headerlink" title="图片外面用个p标签，通过设置line-height使图片垂直居中"></a>图片外面用个p标签，通过设置line-height使图片垂直居中</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">100vh</span>;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">img</span> &#123;</span><br><span class="line">      <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用flex布局"><a href="#利用flex布局" class="headerlink" title="利用flex布局"></a>利用flex布局</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图片垂直居中&quot;&gt;&lt;a href=&quot;#图片垂直居中&quot; class=&quot;headerlink&quot; title=&quot;图片垂直居中&quot;&gt;&lt;/a&gt;图片垂直居中&lt;/h1&gt;&lt;p&gt;在写项目的时候，我想让一张图片垂直居中，可是又不知道怎么做，于是在网上找了一些方案，一下的方法都经过我自己的试验，在我的代码中是能够实现图片垂直居中的效果的&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="https://langliu.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript作用域</title>
    <link href="https://langliu.github.io/2017/03/21/JavaScript-Scopes/"/>
    <id>https://langliu.github.io/2017/03/21/JavaScript-Scopes/</id>
    <published>2017-03-21T00:00:00.000Z</published>
    <updated>2019-10-12T18:50:31.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h2><p>几乎所有的编程语言最基础的功能之一，就是能够储存变量当中的值，并且能够在之后对这个值进行访问和修改。但是这些变量存储在哪里？程序需要的时候怎么找到这些变量呢？这时就需要一套设计良好的规则来存储变量，并且可以方便地找到这些变量，这套规则被称为作用域。</p><a id="more"></a><p>所以说，作用域是一套规则，用于确定在何处以及如何查找变量。</p><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>词法作用域就是定义在词法阶段的作用域。简单说，就是由你写代码时写在哪里来决定的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>); <span class="comment">// 2, 4, 12</span></span><br></pre></td></tr></table></figure><p>上面的代码有三个逐级嵌套的作用域，在 js 中词法作用域规则:</p><ol><li>函数允许访问函数外的数据.</li><li>整个代码结构中只有函数可以限定作用域.</li><li>作用规则首先使用提升规则分析.</li><li>作用域查找会在找到第一个匹配的标识符时停止.</li></ol><h3 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h3><p>由于词法作用域在写代码的时候就已经确定了，那么我们怎么才能在运行的时候来修改词法作用域呢？</p><p>在JavaScript中有两种机制来实现这个目的（<code>eval</code>和<code>with</code>）。但这两种机制并不是什么好主意，因为他们会导致性能的下降，所以不推荐使用欺骗词法，只要知道有这么个东西就好了。</p><h4 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h4><p>JavaScript中的<code>eval(..)</code>可以接受一个字符串作为参数，并将其中的内容视为好像在书写就存在于程序中这个位置的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(str); <span class="comment">//欺骗</span></span><br><span class="line">    <span class="built_in">console</span>.log(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(<span class="string">"var b = 1;"</span>, <span class="number">1</span>); <span class="comment">// 1, 1</span></span><br></pre></td></tr></table></figure><p>从上面代码可以看出，当<code>eval(..)</code>调用传进去的字符串时，程序把该字符串当做本来就在那里一样来处理。因为在字符串中定义了变量b，所以外部的变量b被屏蔽了。</p><h4 id="with"><a href="#with" class="headerlink" title="with"></a>with</h4><p>JavaScript中另一个欺骗词法作用域的机制就是<code>with</code>关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">with</span>(obj) &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，当执行<code>foo(obj)</code>时，<code>obj</code>并没有<code>a</code>属性，因此<code>obj.a</code>为<code>undefined</code>。但是在<code>foo(..)</code>函数中<code>a = 2;</code>却创建了一个全局变量<code>a</code>。</p><p><strong>在严格模式的程序中，<code>eval(..)</code>在运行时有着自己的词法作用域，意味着其中的声明无法修改所在的作用域，而<code>with</code>则被完全禁止了。</strong></p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。</p><h3 id="函数的用途"><a href="#函数的用途" class="headerlink" title="函数的用途"></a>函数的用途</h3><ul><li>隐藏内部实现</li><li>代码复用</li><li>组合调用</li></ul><h3 id="立即执行函数表达式（IIFE）"><a href="#立即执行函数表达式（IIFE）" class="headerlink" title="立即执行函数表达式（IIFE）"></a>立即执行函数表达式（IIFE）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>由于函数被包含在一对( )括号内部，因此成为了一个表达式，通过在末尾加上另外一个( )可以立即执行这个函数。</p><h4 id="两种形式"><a href="#两种形式" class="headerlink" title="两种形式"></a>两种形式</h4><ul><li><code>(function(){ .. })()</code></li><li><code>(function(){ .. }())</code></li></ul><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><p>我在《JavaScript语言精粹》中看到过这样一句话“糟糕的是，尽管Javascript的代码块语法貌似支持块级作用域，实际上JavaScript并不支持。这个混淆之处可能成为错误之源。”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们可以看到在<code>for</code>循环内部定义的变量污染到了全局作用域中。</p><p>那么JavaScript中真的没有块作用域吗？很少有人注意到JavaScript的ES3规范中规定<code>try/catch</code>的<code>catch</code>分句会创建一个块作用域，其中声明的变量仅在catch内部有效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="literal">undefined</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error); <span class="comment">// 能够正常运行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(error); <span class="comment">//</span></span><br></pre></td></tr></table></figure><p>在ES6中，引入了新的<code>let</code>关键字，提供了除了<code>var</code>以外的另一种变量声明方式。<code>let</code>关键字可以将变量绑定到所在的任意作用域中（通常是<code>{ ... }</code>内部）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><p>对比上面的代码，我们可以发现使用<code>let</code>关键字时，块作用域外部并不能访问内部的变量。</p><p>除了<code>let</code>以外，ES6还引入了<code>const</code>，同样可以用来创建块作用域变量，但其值是固定的（常量），之后任何试图修改值的操作都会引起错误。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;作用域是什么&quot;&gt;&lt;a href=&quot;#作用域是什么&quot; class=&quot;headerlink&quot; title=&quot;作用域是什么&quot;&gt;&lt;/a&gt;作用域是什么&lt;/h2&gt;&lt;p&gt;几乎所有的编程语言最基础的功能之一，就是能够储存变量当中的值，并且能够在之后对这个值进行访问和修改。但是这些变量存储在哪里？程序需要的时候怎么找到这些变量呢？这时就需要一套设计良好的规则来存储变量，并且可以方便地找到这些变量，这套规则被称为作用域。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://langliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScript" scheme="https://langliu.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
