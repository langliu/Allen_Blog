{"meta":{"title":"Allen's blog","subtitle":"我的个人博客，用于记录在学习中的一些知识，加强记忆","description":"我的个人博客，用于记录在学习中的一些知识，加强记忆","author":"Allen Liu","url":"https://langliu.github.io"},"pages":[{"title":"","date":"2019-06-28T17:54:44.738Z","updated":"2019-06-28T17:54:44.738Z","comments":false,"path":"categories/index.html","permalink":"https://langliu.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-06-28T17:54:44.738Z","updated":"2019-06-28T17:54:44.738Z","comments":false,"path":"tags/index.html","permalink":"https://langliu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"pandas入门","slug":"pandas入门","date":"2018-08-29T22:46:07.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2018/08/29/pandas入门/","link":"","permalink":"https://langliu.github.io/2018/08/29/pandas入门/","excerpt":"","text":"DataFrame数据选择选择行1234df = DataFrame(&#123; 'name': ['Allen', 'Marry', 'Jack', 'Jason', 'Cherry', 'Aline', 'Timmy', 'Alain'], 'sex': ['m', 'f', 'm', 'm', 'f', 'f', 'm', 'm']&#125;) 获取前n行df.head(n: int)，该方法获取DataFrame的前n行（默认为5） 12345df.head(3)# name sex# 0 Allen m# 1 Marry f# 2 Jack m 获取后n行df.tail(n :int)，该方法获取DataFrame的后n行（默认为5） 12345df.tail(3)# name sex# 5 Aline f# 6 Timmy m# 7 Alain m 获取中间行获取中间行有两种方式： df.iloc[] 和 df.loc[] df.iloc[] 是根据 index 来划分的，而 df.loc[] 是根据 label 划分的 1234df.iloc[1:3, :] # 获取第2，3行数据# name sex# 1 Marry f# 2 Jack m 12345df.loc[1:3, :] # 获取第1，2，3行数据# name sex# 1 Marry f# 2 Jack m# 3 Jason m 选择列获取某一列1df['name'] # 根据列名获取 获取多列1df[['name', 'sex']] # 根据列名获取 获取中间列获取中间列有两种方式： df.iloc[] 和 df.loc[] df.iloc[] 是根据 index 来划分的，而 df.loc[] 是根据 label 划分的 123456789df.iloc[:, 0:2] # 获取第1，2列数据# name sex# 1 Marry f# 2 Jack m# 3 Jason m# 4 Cherry f# 5 Aline f# 6 Timmy m# 7 Alain m 123456789df.loc[:, :'name'] # 获取第2，3行数据# name# 1 Marry# 2 Jack# 3 Jason# 4 Cherry# 5 Aline# 6 Timmy# 7 Alain 重置编号Series重置编号123456s1 = Series([1, 2, 3, 4], index=['A', 'B', 'C', 'D'])# A 1# B 2# C 3# D 4# dtype: int64 reindex() 方法接收一个新的 index 列表，用于替换原来的 index ，如果新的 index 长度大于原来的 index 则新增的一行默认填充为 NaN ，可以通过指定参数 fill_value 改变默认的值。 1234567s1.reindex(index=['A', 'B', 'C', 'D', 'E'])# A 1.0# B 2.0# C 3.0# D 4.0# E NaN# dtype: float64 1234567s1.reindex(index=['A', 'B', 'C', 'D', 'E'], fill_value=0)# A 1# B 2# C 3# D 4# E 0# dtype: int64 重置编号时使用 method=&#39;ffill&#39; 参数可以自动填充Series的值，如下例所示：因index 1，3，5有值，所以填充时1-3之间的填充 index 为1的值，3-5之间的填充 index 为3的值，而 index 为1的因为前面没有值，则为 NaN。 12345678s2 = Series(['A', 'B', 'C'], index=[1, 3, 5])s2 = s2.reindex(index=range(5), method='ffill')# 0 NaN# 1 A# 2 A# 3 B# 4 B# dtype: object 如果要删除某一行可以使用 drop() 方法： 1s2.drop(0)","categories":[{"name":"Python","slug":"Python","permalink":"https://langliu.github.io/categories/Python/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"https://langliu.github.io/tags/数据分析/"},{"name":"Pandas","slug":"Pandas","permalink":"https://langliu.github.io/tags/Pandas/"}]},{"title":"Nginx在Windows下开机自动启动","slug":"Nginx在Windows下开机自动启动","date":"2018-08-26T11:40:59.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2018/08/26/Nginx在Windows下开机自动启动/","link":"","permalink":"https://langliu.github.io/2018/08/26/Nginx在Windows下开机自动启动/","excerpt":"","text":"安装Nginx在Nginx官网下载页面下载Nginx Windows版本，下载后解压，然后运行目录下的 nginx.exe 启动nginx，这时打开浏览器输入 http://localhost:80/ 就可以看见nginx的欢迎页面，说明nginx已经成功启动了。 nginx Windows下开机自启动关闭计算机后重新打开电脑，这时如果再去访问 http://localhost:80/ 会报 404 错误，因为关机后再次开机并不会自动重启Nginx，如果我们需要每次开机后启动Nginx怎么办呢？难道一次次的去nginx目录下运行nginx.exe吗，不，我们有更简单的方式： 我们可以借助Windows Service Wrapper小工具，将Nginx转换为Windows服务，这样就可以在开机时自动启动Nginx了。 下载后将该工具放入Nginx的安装目录下，并且将其重命名为 nginx-service.exe ，在该目录下新建 nginx-service.xml 文件，写入配置信息，配置好了之后就可以通过这个将Nginx注册为Windows服务。 1234567891011&lt;!-- nginx-service.xml --&gt;&lt;service&gt; &lt;id&gt;nginx&lt;/id&gt; &lt;name&gt;nginx&lt;/name&gt; &lt;description&gt;nginx&lt;/description&gt; &lt;logpath&gt;D:nginx-1.14.0\\&lt;/logpath&gt; &lt;logmode&gt;roll&lt;/logmode&gt; &lt;depend&gt;&lt;/depend&gt; &lt;executable&gt;D:nginx-1.14.0\\nginx.exe&lt;/executable&gt; &lt;stopexecutable&gt;D:nginx-1.14.0\\nginx.exe -s stop&lt;/stopexecutable&gt;&lt;/service&gt; 服务命令以上内容配置好了之后，在nginx安装目录下以管理员运行命令：.\\nginx-service.exe install 就成功将其注册为Windows服务了，然后运行 .\\nginx-service.exe start 启动服务。这时我们可以在Windows任务管理器的服务中查看该是否成功启动。 注： nginx-service.exe install 命令可注册对应的系统服务 nginx-service.exe uninstall 命令可删除对应的系统服务 nginx-service.exe stop 命令可停止对应的系统服务 nginx-service.exe start 命令可启动对应的系统服务","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://langliu.github.io/categories/环境配置/"}],"tags":[]},{"title":"vue-cli3 设置反向代理","slug":"Vue-CLI3设置反向代理","date":"2018-08-25T15:55:02.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2018/08/25/Vue-CLI3设置反向代理/","link":"","permalink":"https://langliu.github.io/2018/08/25/Vue-CLI3设置反向代理/","excerpt":"最近在项目中使用了Vue CLI 3.0版本，项目中需要设置反向代理解决跨域问题，下面记录一下设置过程。","text":"最近在项目中使用了Vue CLI 3.0版本，项目中需要设置反向代理解决跨域问题，下面记录一下设置过程。 新建配置文件在项目的根目录下新建 vue.config.js 文件，自Vue CLI 3开始，项目中所有的配置信息都写在这个文件中（2在config目录中配置）。 配置反向代理设置代理123456789101112131415module.exports = &#123; devServer: &#123; // 设置代理 proxy: &#123; \"/v1\": &#123; target: \"http://127.0.0.1:8081/\", // 域名 ws: true, // 是否启用websockets changOrigin: true, //开启代理：在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题 pathRequiresRewrite: &#123; \"^/v1\": \"/\" &#125; &#125; &#125; &#125;&#125;; 在请求中使用123// '/v1'等于'http://127.0.0.1:8081/v1'// 此时请求地址为'http://127.0.0.1:8081/v1/picture?method=upload'get('/v1/picture?method=upload') 更多更多内容请参考Vue CLI官方文档https://cli.vuejs.org/zh/config/#devserver-proxy","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://langliu.github.io/tags/Vue/"}]},{"title":"Numpy中的数组","slug":"Numpy中的数组","date":"2018-07-29T23:28:21.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2018/07/29/Numpy中的数组/","link":"","permalink":"https://langliu.github.io/2018/07/29/Numpy中的数组/","excerpt":"NumPy 中定义的最重要的对象是称为 ndarray 的N维数组类型。它描述相同类型的元素集合。可以使用基于零的索引访问集合中的项目。","text":"NumPy 中定义的最重要的对象是称为 ndarray 的N维数组类型。它描述相同类型的元素集合。可以使用基于零的索引访问集合中的项目。 ndarray 中的每个元素在内存中使用相同大小的块。 ndarray中的每个元素是数据类型对象的对象(称为 dtype)。 从 ndarray 对象提取的任何元素(通过切片)由一个数组标量类型的 Python 对象表示。 数组的使用创建通过已有列表创建： 12345import numpy as nplist_1 = [1, 2, 3, 4]array_1 = np.array(list_1) # 1x4的一维数组array_2 = np.array([list_1, [5, 6, 7, 8]]) # 2x4的二维数组 通过 arange() 创建： 123array_3 = np.arange(5) # [0 1 2 3 4]array_4 = np.arange(2, 5) # [2 3 4]array_5 = np.arange(1, 10, 2) # [1 3 5 7 9] 通过 zeros() 创建全零数组： 12array_6 = np.zeros(5) # [0. 0. 0. 0. 0.]array_7 = np.zeros([2, 3]) # 2x3的全零数组 通过 eye() 创建单位数组： 1array_8 = np.eye(3) # 3x3的单位数组 通过 random.randn() 创建随机数组： 1array_9 = np.random.randn(5) # 会生成一个一行五列的随机数数组 通过 random.randint() 创建随机数组： 12array_10 = np.random.randint(6, size=(3, 2)) # 生成一个元素小于6的3行2列的随机数组array_10 = np.random.randint(6, size=3) # 生成一个元素小于6的1行3列的随机数组 访问获取数组的轴数： 1array_8.ndim # 3 表明数组有3列 获取数组的形状： 12array_6.shape # (5,) 表明array_6是一个 1x5 的数组array_8.shape # (3, 3) 表明array_8是一个 3x3 的数组 获取数组的大小： 1array_8.size # 9 表明array_8有9个元素 获数组元素的数据类型： 12array_5.dtype # int32array_8.dtype # float64 获取数组中的元素： 12345array_1[0] # 1 获取一维数组的第一个元素array_2[0] # [1 2 3 4] 获取二维数组的第一行的元素array_2[1][2] # 3 获取二维数组第二行第三列的元素array_2[0][:2] # [1 2 3] 获取二维数组第一行的前三个元素array_2[:,:3] # [[1 2 3] [1 2 3]] 获取数组第一行第一个元素至最后一行第3个元素区域的元素 数组运算数组的加减法和乘法： 12345arr_1 = np.array([1, 2, 3])arr_2 = np.array([4, 5, 6])arr_sum = arr_1 + arr_2 # [5, 7, 9]arr_sub = arr_2 - arr_1 # [3, 3, 3]arr_mul = arr_1 * arr_2 # [4 10 18] 数组的除法： 123arr_mul = arr_1 / arr_2 # [0.25 0.4 0.5]arr_3 = [1, 2, 0]arr_mul1 = arr_1 / arr_3 # [ 1. 1. inf] 除数为0时python会报警告，然后对应的结果为 `inf` 数组的常用方法重置数组的形状： ndarry.reshape() 1arr_4 = np.random.randint(10, size=20).reshape(4, 5) # 生成一个4x5的随机数组 求数组中的元素：np.unique(ndarray) 12arr_5 = np.array([1, 3, 5, 2, 1])arr_5_unique = np.unique(arr_5) # [1 2 3 5] 数组求和：sum(ndarray) 对于一维数组直接求取所有元素的和，对于二维数组则求取每列元素的和，返回一个新的数组。 123sum(arr_5) # 12arr_6 = np.array([[1, 3, 5, 2, 1], [1, 3, 5, 2, 1]])sum(arr_6) # [ 2 6 10 4 2] 求数组中元素的最大值：ndarray.max() 123arr_6.max() # 5max(arr_6[0]) # 5 求取第一行的最大值max(arr_6[:, 0]) # 1 求取第一列的最大值 数组的文件读写：单个数组的读写： 123arr = np.arange(10)np.save('arr.npy', arr)a = np.load('arr.npy') # [0 1 2 3 4 5 6 7 8 9] 多个数组的读写： 123456arr_1 = np.arange(10)arr_2 = np.arange(0, 10, 2)np.savez('arr.npz', x=arr_1, y=arr_2)a = np.load('arr.npz')print(a['x']) # [0 1 2 3 4 5 6 7 8 9]print(a['y']) # [0 2 4 6 8] 其他如果数组创建时同时包含 int 和 float 类型的元素，则数组创建后所有元素都将被转为 float 类型。只有只包含 int 类型的元素的数组的元素才为 int 类型。","categories":[{"name":"Python","slug":"Python","permalink":"https://langliu.github.io/categories/Python/"}],"tags":[{"name":"NumPy","slug":"NumPy","permalink":"https://langliu.github.io/tags/NumPy/"}]},{"title":"Python中的循环","slug":"Python中的循环","date":"2018-06-28T00:44:09.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2018/06/28/Python中的循环/","link":"","permalink":"https://langliu.github.io/2018/06/28/Python中的循环/","excerpt":"Python中的循环有两种： while 和 for ，同其他语言不同的是，这两种方式可以联合 else 语句一起使用。","text":"Python中的循环有两种： while 和 for ，同其他语言不同的是，这两种方式可以联合 else 语句一起使用。 while语句使用 while 时如果想要输出1-10的数字，我们可以使用以下代码： 12345counter = 0while counter &lt; 10: counter += 1 print(counter) 当输出1-10之后程序结束运行，如果想要在 while 语句结束后输出一个结束标志怎么办呢？ 1234567counter = 0while counter &lt; 10: counter += 1 print(counter)else: print('END') for语句for 语句主要用来遍历/循环 序列、字典或者集合 如果要向上面那样输出1-10，如以下代码所示： 1234for num in range(1,11): print(num)else: print('END') 如果在 for 语句中想要获取数组的下标，可以使用Python内置的 enumerate() 函数： 1234for index,value in enumerate(range(1,11)): print('index: %s, value: %s' % (index, value))else: print('END') break在循环中， break 语句可以提前退出循环。例如，本来要循环打印1～10的数字，如果要在6之后退出循环： 123456for num in range(1,11): print(num) if num == 6: breakelse: print('END') continue在循环过程中，也可以通过 continue 语句，跳过当前的这次循环，直接开始下一次循环,如果我们要打印1-10中的奇数： 123456for num in range(1,11): if num % 2 == 0: continue print(num)else: print('END')","categories":[{"name":"Python","slug":"Python","permalink":"https://langliu.github.io/categories/Python/"}],"tags":[{"name":"Python语法","slug":"Python语法","permalink":"https://langliu.github.io/tags/Python语法/"}]},{"title":"回文十进制数","slug":"回文十进制数","date":"2018-05-16T00:21:51.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2018/05/16/回文十进制数/","link":"","permalink":"https://langliu.github.io/2018/05/16/回文十进制数/","excerpt":"题目描述如果把某个数的各个数字按相反的顺序排列，得到的数和原来的数相同，则这个数就是“回文数”。譬如123454321就是一个回文数。 求用十进制、二进制、八进制表示都是回文数的所有数字中，大于十进制数10的最小值。","text":"题目描述如果把某个数的各个数字按相反的顺序排列，得到的数和原来的数相同，则这个数就是“回文数”。譬如123454321就是一个回文数。 求用十进制、二进制、八进制表示都是回文数的所有数字中，大于十进制数10的最小值。 解题方案：思路： 将该数分别转换为十进制、二进制、八进制表示，分别判断是否为回文数，如果该数的十进制、二进制、八进制表示都是回文数的话则该数满足条件 将该数转换为二进制时，第一位是1，如果该数是回文数的话则该数的最后一位也为1，所以该数只能为奇数 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# /usr/bin/env python3# -*- coding: utf-8 -*-\"\"\"@author: Allen@contact: 809721414@qq.com@time: 2018/5/14 10:15\"\"\"def palindromes_binary_number(number: int) -&gt; bool: \"\"\" 判断一个数的是否为二进制回文数 :param number: int(要判断的数字) :return: bool(判断结果) &gt;&gt;&gt; palindromes_binary_number(5) True &gt;&gt;&gt; palindromes_binary_number(6) False &gt;&gt;&gt; palindromes_binary_number(7) True \"\"\" bin_number = bin(number) new_list = list(bin_number[2:]) new_list.reverse() return bin_number[2:] == list_to_str(new_list)def palindromes_octal_number(number: int) -&gt; bool: \"\"\" 判断一个数的是否为八进制回文数 :param number: int(要判断的数字) :return: bool(判断结果) &gt;&gt;&gt; palindromes_octal_number(9) True &gt;&gt;&gt; palindromes_binary_number(14) False &gt;&gt;&gt; palindromes_binary_number(7) True \"\"\" oct_number = oct(number) new_list = list(oct_number[2:]) new_list.reverse() return oct_number[2:] == list_to_str(new_list)def palindromes_decimal_number(number: int) -&gt; bool: \"\"\" 判断一个整数是否为十进制回文数 :param number: int(要判断的数字) :return: bool(判断结果) &gt;&gt;&gt; palindromes_decimal_number(11) True &gt;&gt;&gt; palindromes_decimal_number(12) False \"\"\" new_list = list(str(number)) new_list.reverse() return number == int(list_to_str(new_list))def list_to_str(one_list: list) -&gt; str: \"\"\" 将列表转为字符串 :param one_list: list(要转换的列表) :return: str(转换后的字符串) &gt;&gt;&gt; list_to_str([1, 2, 3]) '123' &gt;&gt;&gt; list_to_str([12, '123', 1324]) '121231324' \"\"\" return ''.join(list(map(str, one_list)))if __name__ == '__main__': import doctest doctest.testmod(verbose=True) num = 11 while True: if palindromes_decimal_number(num) and palindromes_binary_number(num) and palindromes_octal_number(num): break else: num = num + 2 print(num)","categories":[{"name":"算法","slug":"算法","permalink":"https://langliu.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://langliu.github.io/tags/算法/"}]},{"title":"使用Flow来检测你的Js","slug":"使用Flow来检测你的Js","date":"2018-01-17T23:53:11.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2018/01/17/使用Flow来检测你的Js/","link":"","permalink":"https://langliu.github.io/2018/01/17/使用Flow来检测你的Js/","excerpt":"最近在一篇文章上看见了关于Flow的介绍，觉得它很不错，虽然之前在项目中使用Typescript已经很顺手了，再使用Flow感觉有点累赘了，但多学点总是没错的。","text":"最近在一篇文章上看见了关于Flow的介绍，觉得它很不错，虽然之前在项目中使用Typescript已经很顺手了，再使用Flow感觉有点累赘了，但多学点总是没错的。 简介JS作为一种脚本语言是没有类型检测的，这个特点有时候用着很爽，但当你在一个较大的项目中的时候，就会发现这其实是一件挺糟糕的事情，因为和你协作的程序员往往不太清楚你所写的代码到底哪种类型才是正确的，而且代码重构的时候也很麻烦。于是基于这个需求有了Typescript和Flow的产生，今天这里主要介绍Flow。 安装因为笔者一直使用的是WebStorm，WebStorm内部对Flow就有一定的支持，所以如果你也使用WebStorm的话会方便很多。 1yarn add --dev flow-bin babel-cli babel-preset-flow 在安装了上述的包之后，创建 .babelrc 文件： 123&#123; \"presets\": [\"flow\"]&#125; 设置WebStorm通过 File&gt;Settings&gt;Languages&amp;Frameworks&gt;JavaScript 如下图所示设置，Flow package可以选择你项目下的flow-bin，当然你也可以全局安装flow-bin，然后在这里设置后就可以在每个项目中都使用Flow了 。 Flow-Settings flow不能直接在node或浏览器环境中使用，所以我们必须用babel编译后才能使用： Snipaste_2018-01-15_23-54-48.png 现在环境已经快配好了，只剩最后一步，将一个此项目初始化为一个Flow项目： 1yarn run flow init Snipaste_2018-01-16_00-00-14.png 现在当我们在项目中使用Flow时WebStorm可以给出智能的提示了。 使用类型最新的 ECMAScript 标准定义了 7 种数据类型: 6 种 原始类型: Boolean Null Undefined Number String Symbol (ECMAScript 6 新定义) 和 Object 在Flow中也是使用这几种类型作为标注: 使用原始类型： 123456// @flowfunction method(x: number, y: string, z: boolean) &#123; // ...&#125;method(3.14, \"hello\", true); 使用对象类型： 123456// @flowfunction method(x: Number, y: String, z: Boolean) &#123; // ...&#125;method(new Number(42), new String(\"world\"), new Boolean(false)); 这里需要注意的是大小写，小写的 number 是原始类型，而大写的 Number 是JavaScript的构造函数，是对象类型的。 Boolean在Flow中，默认并不会转换类型，如果你需要转换类型请使用显示或隐式转换，例如： 12345678910// @flowfunction acceptsBoolean(value: boolean) &#123; // ...&#125;acceptsBoolean(true); // Works!acceptsBoolean(false); // Works!acceptsBoolean(\"foo\"); // Error!acceptsBoolean(Boolean(\"foo\")); // Works!acceptsBoolean(!!(\"foo\")); // Works! Number12345678910// @flowfunction acceptsNumber(value: number) &#123; // ...&#125;acceptsNumber(42); // Works!acceptsNumber(3.14); // Works!acceptsNumber(NaN); // Works!acceptsNumber(Infinity); // Works!acceptsNumber(\"foo\"); // Error! null和voidJavaScript兼有 null 和 undefined。Flow将这些视为单独的类型：null 和 void（void表示undefined类型） 12345678910111213// @flowfunction acceptsNull(value: null) &#123; /* ... */&#125;function acceptsUndefined(value: void) &#123; /* ... */&#125;acceptsNull(null); // Works!acceptsNull(undefined); // Error!acceptsUndefined(null); // Error!acceptsUndefined(undefined); // Works! 也许类型也许类型是用于可选值的地方，你可以通过在类型前添加一个问号（如 ?string 或者 ?number）来创建它们。 除了问号 ? 后跟着的类型，也许类型也可以是 null 或者 void 类型。 123456789// @flowfunction acceptsMaybeString(value: ?string) &#123; // ...&#125;acceptsMaybeString(\"bar\"); // Works!acceptsMaybeString(undefined); // Works!acceptsMaybeString(null); // Works!acceptsMaybeString(); // Works! 可选的对象属性对象类型可以具有可选属性，问号 ? 位于属性名称后面。 1&#123; propertyName?: string &#125; 除了它们的设定值类型之外，这些可选属性也可以被 void 完全省略。但是，他们不能 null。 123456789// @flowfunction acceptsObject(value: &#123; foo?: string &#125;) &#123; // ...&#125;acceptsObject(&#123; foo: \"bar\" &#125;); // Works!acceptsObject(&#123; foo: undefined &#125;); // Works!acceptsObject(&#123; foo: null &#125;); // Error!acceptsObject(&#123;&#125;); // Works! 可选的函数参数函数可以具有可选参数，其中问号 ? 出现在参数名称后面。同样，该参数不能为 null。 123456789// @flowfunction acceptsOptionalString(value?: string) &#123; // ...&#125;acceptsOptionalString(\"bar\"); // Works!acceptsOptionalString(undefined); // Works!acceptsOptionalString(null); // Error!acceptsOptionalString(); // Works! 文字类型文字类型使用一个具体的值作为类型： 12345function foo(value: 2) &#123;&#125;foo(2); // Work!foo(3); // Error!foo('2'); // Error! 您可以使用这些类型的原始值： 布尔人： true 或 false 数字：像 42 或 3.14 字符串：像 &quot;foo&quot; 或 &quot;bar&quot; 12345678910111213// @flowfunction getColor(name: \"success\" | \"warning\" | \"danger\") &#123; switch (name) &#123; case \"success\" : return \"green\"; case \"warning\" : return \"yellow\"; case \"danger\" : return \"red\"; &#125;&#125;getColor(\"success\"); // Works!getColor(\"danger\"); // Works!// $ExpectErrorgetColor(\"error\"); // Error! 混合类型 mixed有时候我们并不能确定需要的值到底是哪种类型，这时候我们可以使用混合类型来表示，但在使用该值之前，我们需要判断该值到底是哪种类型，否则会引起错误： 1234567// @flowfunction stringify(value: mixed) &#123; // $ExpectError return \"\" + value; // Error!&#125;stringify(\"foo\"); 12345678910// @flowfunction stringify(value: mixed) &#123; if (typeof value === 'string') &#123; return \"\" + value; // Works! &#125; else &#123; return \"\"; &#125;&#125;stringify(\"foo\"); 任意类型 any如果你想要一种方法来选择不使用类型检查器，any 是做到这一点的方法。 使用any是完全不安全的，应尽可能避免。 例如，下面的代码不会报告任何错误： 12345678// @flowfunction add(one: any, two: any): number &#123; return one + two;&#125;add(1, 2); // Works.add(\"1\", \"2\"); // Works.add(&#123;&#125;, []); // Works. 接口类型 interface你可以使用 interface 以声明您期望的类的结构。 123456789101112131415// @flowinterface Serializable &#123; serialize(): string;&#125;class Foo &#123; serialize() &#123; return '[Foo]'; &#125;&#125;class Bar &#123; serialize() &#123; return '[Bar]'; &#125;&#125;const foo: Serializable = new Foo(); // Works!const bar: Serializable = new Bar(); // Works! 你也可以使用 implements 告诉Flow，你希望类匹配一个接口。这可以防止编辑类时发生不兼容的更改。 12345678910111213// @flowinterface Serializable &#123; serialize(): string;&#125;class Foo implements Serializable &#123; serialize() &#123; return '[Foo]'; &#125; // Works!&#125;class Bar implements Serializable &#123; // $ExpectError serialize() &#123; return 42; &#125; // Error!&#125; 数组类型 Array要创建一个数组类型，可以使用 Array&lt;Type&gt; 类型，其中 Type 是数组中元素的类型。例如，为你使用的数字数组创建一个类型 Array&lt;number&gt;。 1let arr: Array&lt;number&gt; = [1, 2, 3]; 暂时就介绍这么多，还有一些类型文章中没有提到，更多更详细的内容请在Flow官网中查看。","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://langliu.github.io/tags/JavaScript/"}]},{"title":"HTML5.2新特性","slug":"HTML5-2新特性","date":"2018-01-10T23:12:16.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2018/01/10/HTML5-2新特性/","link":"","permalink":"https://langliu.github.io/2018/01/10/HTML5-2新特性/","excerpt":"在去年的12月份W3C组织发布了HTML5.2版本，这个版本对之前的规范又有了一些添加和修改，有些有意思的内容可以极大的方便我们的编码，下面我们一起来看一看这些变化。具体的变化可以在这里看见。","text":"在去年的12月份W3C组织发布了HTML5.2版本，这个版本对之前的规范又有了一些添加和修改，有些有意思的内容可以极大的方便我们的编码，下面我们一起来看一看这些变化。具体的变化可以在这里看见。 新增标签dialogdialog 标签可以帮助我们快速的实现一个对话框，在之前如果我们想要实现一个对话框，大都是先写一个 div 元素，然后设置CSS将其隐藏，在需要显示时再改变其CSS属性将其显示，而如果使用 dialog 标签只需要几行代码就可以实现这个功能： 123456789101112131415161718&lt;dialog id=\"dialog\"&gt; &lt;h1&gt;hello, world!&lt;/h1&gt; &lt;p&gt;这是一个dialog&lt;/p&gt; &lt;button id=\"close-dialog\"&gt;关闭对话框&lt;/button&gt;&lt;/dialog&gt;&lt;button id=\"btn\"&gt;打开对话框&lt;/button&gt;&lt;script&gt; const dialog = document.getElementById('dialog'); const btn = document.getElementById('btn'); const closeDialog = document.getElementById('close-dialog'); btn.onclick = function () &#123; dialog.show(); console.log('open dialog'); &#125;; closeDialog.onclick = () =&gt; &#123; dialog.close(); &#125;;&lt;/script&gt; 当点击打开对话框按钮打开对话框后，页面就像下图所示： dialog 如果想要关闭对话框只需要调用 close() 方法，如果想要对话框在一开始的时候就显示，只需要给 dialog 元素添加 open 属性即可： 12345&lt;dialog id=\"dialog\" open&gt; &lt;h1&gt;hello, world!&lt;/h1&gt; &lt;p&gt;这是一个dialog&lt;/p&gt; &lt;button id=\"close-dialog\"&gt;关闭对话框&lt;/button&gt;&lt;/dialog&gt; 当使用 show() 方法打开dialog的时候我们还是可以点击对话框外的其他内容，如果我们不想在打开对话框的时候屏幕的其他内容可以点击，要给他加一个遮罩层该怎么办呢？很简单，我们只需要使用 showModal() 方法来打开dialog就好。使用 showModal() 方法打开的dialog在显示对话框的同时，会在你页面的顶层显示一个遮罩层，以防止你去操作除对话框以外的它元素。 有一点需要注意的地方是当你给 dialog 元素添加 open 属性后，就不能够再去调用 showModal() 方法来打开dialog，否则会报一个 Untitled-1.html:28 Uncaught DOMException: Failed to execute &#39;showModal&#39; on &#39;HTMLDialogElement&#39;: The element already has an &#39;open&#39; attribute, and therefore cannot be opened modally. 的错。 已删除的内容 keygen，menu和menuitem元素。 在inputmode对文本属性的input元素和dropzone属性。 该showModalDialog方法。 插件API已被标记为废弃。 修改 停止非网络来源的媒体资源请求延迟 load 事件。 删除刷新率的任意上限。 坐标 ismap 不再包含计算中的图像边界。 将accesskey定义更新为需要单个可打印的字符。 修复激活算法 summary 以符合实际。 修复算法以确定行和列标题 table。 更新渲染 summary 反映破损的URL会返回未解析的值 currentScript 可能会返回 SVGScriptElement。 重置一个 textarea 重置它的脏值标志。 document.open() 并 document.close() 检查XML文档。 HashChangeEvent 网址是，USVString 而不是 DOMString。 选择成员的类型是可空的。 data: 网址被视为一个单独的来源。 可悲的是，只有具有tabindex属性的元素通常不会click在用非指针设备激活时触发事件。 导航沙盒上下文 role根据 [html-aria] 更新的允许值 &lt;style&gt; 标签位于 &lt;body&gt;之内。 多个 &lt;main&gt; 标签在DOM元素中，只要只有一个是对用户可见。 &lt;img&gt; 元素的演示。 &lt;div&gt; 作为一个 &lt;dl&gt; 元素的子元素。 &lt;dfn&gt; 作为 &lt;li&gt; 包含定义的术语定义的元素的后代。 &lt;legend&gt; 在一个内部的标题&lt;fieldset&gt;。 &lt;option&gt; 作为孩子的空元素 &lt;datalist&gt;。 在HTML语法中包含两个连续的连字符的注释或以连字符结尾的注释。 去除BiDi算法部分的限制","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://langliu.github.io/tags/HTML5/"}]},{"title":"Python中的list和tuple","slug":"Python中的list和tuple","date":"2018-01-04T22:52:55.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2018/01/04/Python中的list和tuple/","link":"","permalink":"https://langliu.github.io/2018/01/04/Python中的list和tuple/","excerpt":"listPython内置的一种数据类型是列表：list。list是Python的一种叫法，和其他语言中的数组一样，是一种有序的数据集合，可以随时向其中添加和删除元素。","text":"listPython内置的一种数据类型是列表：list。list是Python的一种叫法，和其他语言中的数组一样，是一种有序的数据集合，可以随时向其中添加和删除元素。 一个基本的表示姓名的list： 1names = ['Allen', 'Youngor', 'Jack'] 可以用len()函数获得list元素的个数： 1len(names) # 3 使用索引来访问list中每一个位置的元素，索引从0开始，如果从最后一个元素开始获取元素，可以用负数表示： 1234names[0] # 'Allen'names[1] # 'Youngor'names[-1] # 'Jack'names[-2] # 'Youngor' 当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界。 如果要删除列表中的一个元素，可以使用 del 语句： 123nums = [1, 2, 3, 4]del nums[1]print(nums) # [1, 3, 4] 高级特性切片在使用list的时候，我们可能会经常需要取出list的某一部分元素，如果用循环去取的话非常笨重，Python为我们提供了一个非常方便的方法取出list的一部分，那就是切片。 1list[start:end:step] 切片方法可以有三个参数： start：起始位置（需要截取的list的开始位置） end：结束位置（需要截取的list的结束位置，结果不包括该位置的值） step：步长（每个步长取一个元素，默认为1） 12345678910nums = [1, 2, 3, 4, 5, 6, 7]# 从索引3开始取，到索引5为止nums[3:5] # [4, 5]# 从第0个元素开始，直到最后一个元素，每两个元素取一个nums[::2] # [1, 3, 5, 7]# 索引也可以使用负数表示nums[-3:-1] # [5, 6] 重复列表在Python中，如果要创建一个长度为10的list，并其list的每个元素全初始化为0，应该怎么做？ 在其他的语言中你可能是使用循环来创建，但是在Python中只要一行代码就可以轻松创建： 1nums = [0] * 10 # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 判断元素是否在列表中在Python中可以使用 in 操作符判断一个元素是否存在于一个列表中： 12names = ['Allen', 'Youngor', 'Lvy']print('Allen' in names) # True 组合列表在Python中，我们可以使用 + 运算符将两个list组合在一起，像连接两个字符串一样： 123num1 = [1, 2, 3]num2 = [4, 5, 6]print(num1 + num2) # [1, 2, 3, 4, 5, 6] 列表生成式要生成一些简单的列表我们可以通过 list(range(10)) 这种方式，但是如果我们需要一个幂数列的列表呢？ 在其他语言中，我们只能通过循环的方式来生成，但是在python中却有一种更简单的方式来生成这种复杂的列表，那就是列表生成式： 12l = [x * x for x in range(1,10)]print(l) # [1, 4, 9, 16, 25, 36, 49, 64, 81] for循环后面还可以加上if判断，这样我们可以快速的选出我们想要的数据： 12l = [x * x for x in range(1,10) if x % 3 == 0]print(l) # [9, 36, 81] 还可以使用两层循环，可以生成全排列： 12l = [m + n for m in 'ABC' for n in 'XYZ']print(l) # ['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 常用方法append()append(value) 方法向list末尾追加一个元素： 1names.append('Lvy') # ['Allen', 'Youngor', 'Jack', 'Lvy'] insert()insert(index, value) 方法把元素插入到list中指定的位置： 1names.insert(1, 'Bob') # ['Allen', 'Bob', 'Youngor', 'Jack'] pop()pop(index) 方法删除ist中指定位置的元素，如果要删除末尾的元素，则可以不传入索引位置。该方法返回删除的元素的值： 12names.pop(1) # 'Youngor'names.pop() # 'Jack' count()count(value) 方法用作统计某个元素在列表中出现的次数： 1names.count('Allen') # 1 remove()remove(value) 方法移除列表中某个值的第一个匹配项： 12names.remove('Allen')print(names) # ['Youngor', 'Jack'] 如果该元素不在列表中，则会报错： 1names.remove('Tom') # ValueError: list.remove(x): x not in list reverse()reverse() 方法反向列表中元素 12names.reverse()print(names) # ['Jack', 'Youngor', 'Allen'] index()index(value) 方法从列表中找出某个值第一个匹配项的索引位置，如果列表中存在该值，返回该值的索引。如果该值不存在，抛出一个 ValueError 123names = ['Allen', 'Youngor', 'Jack']print(names.index('Allen')) # 0print(names.index('Tom')) # ValueError: 'Tom' is not in list extend()extend(obj) 方法在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表），需要传入的参数是一个可迭代对象： 123names = ['Allen', 'Youngor', 'Jack']names.extend('123')print(names) # ['Allen', 'Youngor', 'Jack', '1', '2', '3'] clear()clear() 方法清除列表中所有的元素： 12names.clear()print(names) # [] copy()copy() 方法用于拷贝一个list（深拷贝）： 12345names = ['Allen', 'Youngor', 'Jack']names_copy = names.copy()names.append('Tim')print(names_copy) # ['Allen', 'Youngor', 'Jack']print(names) # ['Allen', 'Youngor', 'Jack', 'Tim'] sort()sort(fun) 方法对列表进行排序： 123nums = [1, 23, 34, 2, 56, 5, 4]nums.sort()print(nums) # [1, 2, 4, 5, 23, 34, 56] tupletuple和list非常相似，但是tuple一旦初始化就不能修改，所以tuple必须在定义的时候就初始化完成。 同样表示姓名的tuple: 1names = ('Allen', 'Youngor', 'Jack') 同list一样，我们也可以通过索引取得tuple的元素的值： 1names[0] # 'Allen' 如果要定义一个只有一个元素的tuple，必须在结尾加一个,来消除歧义，因为()既可以表示tuple又可以表示数学公式中的小括号： 12num = (1) # 1num = (1,) # (1,)","categories":[{"name":"Python","slug":"Python","permalink":"https://langliu.github.io/categories/Python/"}],"tags":[{"name":"Python语法","slug":"Python语法","permalink":"https://langliu.github.io/tags/Python语法/"}]},{"title":"Video标签","slug":"Video标签","date":"2018-01-02T23:28:45.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2018/01/02/Video标签/","link":"","permalink":"https://langliu.github.io/2018/01/02/Video标签/","excerpt":"关于HTML5中的 video 标签之前一直就知道它是HTML5的新特性，可是在之前的项目中一直也没有视频的内容，所以对其的印象不深，在这次的项目中，有大量的视频展示，所以在写项目时有用到较多的 video 标签，这次之后对其的了解加深了许多。","text":"关于HTML5中的 video 标签之前一直就知道它是HTML5的新特性，可是在之前的项目中一直也没有视频的内容，所以对其的印象不深，在这次的项目中，有大量的视频展示，所以在写项目时有用到较多的 video 标签，这次之后对其的了解加深了许多。 一个简单的实例直接使用 12&lt;!-- 可以在开始标签和结束标签之间放置文本内容，这样老的浏览器就可以显示出不支持该标签的信息。 --&gt;&lt;video src=\"moive.mp4\" type=\"video/mp4\"&gt;您的浏览器不支持video标签,请更新您的浏览器&lt;/video&gt; 配合 source 标签一起使用(source 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式)： 1234&lt;video&gt; &lt;source src=\"movie.mp4\"&gt; &lt;source src=\"movie.ogg\"&gt;&lt;/video&gt; 常用属性 controls: 如果出现该属性,则向用户显示控件,比如播放按钮。 autoplay: 如果出现该属性,则视频就绪后立刻播放 loop: 如果出现该属性,则视频播放完成后会继续循环播放 preload: 如果出现该属性,则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。 height: 设置播放器的高度 width: 设置播放器的宽度 poster: 一个海报帧的URL，用于在用户播放或者跳帧之前展示。如果属性未指定，那么在第一帧可用之前什么都不会展示；之后第一帧就像海报帧一样展示。 muted: 指明了视频里的音频的默认设置 通过JavaScript操作video方法 paly(): 播放视频 pause(): 暂停播放视频 load(): 属性 paused: 布尔值,表示视频是否暂停播放 currentTime: 数值,表示视频目前播放到多少时间","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://langliu.github.io/tags/HTML5/"}]},{"title":"跳台阶","slug":"跳台阶","date":"2017-12-31T23:51:41.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/12/31/跳台阶/","link":"","permalink":"https://langliu.github.io/2017/12/31/跳台阶/","excerpt":"题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。","text":"题目描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 解题方案：思路： 当跳上第一级台阶时只有一种跳法，当跳上第二级台阶时有两种跳法 当第三级台阶时有两种方式：从第一级台阶跳两级；从第二级台阶跳一级。以此类推，后面的第n级台阶到达的方式应该是到第n-1级台阶和第n-2级台阶的方式的和f(n) = f(n-1) + f(n-2) 代码：123456789101112131415161718192021222324function jumpFloor(number) &#123; if (number &lt; 1) &#123; throw new Error('不能小于1'); &#125; else if (number === 1) &#123; return 1; &#125; else if (number === 2) &#123; return 2; &#125; else &#123; /** * result - 到达第number级台阶的跳法 * a - 到达第number-2级台阶的跳法 * b - 到达第number-1级台阶的跳法 */ let [result, a, b] = [0, 1, 2]; // 从第3级台阶开始，计算到达第index级台阶的跳法 for (let index = 3; index &lt;= number; index++) &#123; // 到达第index级台阶的跳法 result = a + b; // 跟新前两次的跳法 [a, b] = [b, result]; &#125; return result; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://langliu.github.io/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://langliu.github.io/tags/算法/"}]},{"title":"Web安全-XSS","slug":"Web安全-XSS","date":"2017-10-26T22:54:59.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/10/26/Web安全-XSS/","link":"","permalink":"https://langliu.github.io/2017/10/26/Web安全-XSS/","excerpt":"XSS的攻击方式反射型发出请求时，XSS代码出现在URL中，作为输出提交到服务端，服务端解析响应后，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。 储存型存储型XSS和反射型XSS的差别仅在于提交的代码会存储在服务端，下次 请求目标页面是不用再次提交XSS代码。","text":"XSS的攻击方式反射型发出请求时，XSS代码出现在URL中，作为输出提交到服务端，服务端解析响应后，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。 储存型存储型XSS和反射型XSS的差别仅在于提交的代码会存储在服务端，下次 请求目标页面是不用再次提交XSS代码。 反射型示例1234567891011121314151617181920212223242526272829303132333435# 安装express生成器$ npm install --global express-generator# 生成一个新的项目$ express -e xss# 修改模板文件 `index.ejs`&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &lt;div&gt; &lt;%- xss %&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;# 修改路由配置文件 `index.js`var express = require(\"express\");var router = express.Router();/* GET home page. */router.get(\"/\", function(req, res, next) &#123; res.render(\"index\", &#123; title: \"Express\", xss: req.query.xss &#125;);&#125;);module.exports = router;# 启动项目$ npm start 当你通过浏览器url传入xss参数时，后端响应后传回给前端，前端直接绑定响应结果。可以通过这种方式在你也页面插入不安全的内容，比如说插入一个 &lt;iframe&gt; 窗口，使你的页面嵌入一些广告或其他内容。 XSS 防御措施 编码： 对用户输入的数据进行HTML Entity编码 过滤： 移除用户上传的DOM属性，如onerror等 移除用户上传的Style节点、Script节点、Iframe节点等 校正 避免直接对HTML Entity解码 使用DOM Parse解码，校正不配对的DOM标签","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://langliu.github.io/tags/JavaScript/"}]},{"title":"JavaScript-Array类型","slug":"JavaScript-Array类型","date":"2017-10-22T14:54:25.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/10/22/JavaScript-Array类型/","link":"","permalink":"https://langliu.github.io/2017/10/22/JavaScript-Array类型/","excerpt":"在JavaScript中除了Object类型外Array类型是使用最多的类型了，但是一直对其中的方法没有记得很熟练，于是写下这篇文章来记一下。","text":"在JavaScript中除了Object类型外Array类型是使用最多的类型了，但是一直对其中的方法没有记得很熟练，于是写下这篇文章来记一下。 数组的创建数组的创建有两种方式：字面量和构造函数 构造函数方式构造函数接受零个或多个参数： 当参数为零时，创建一个空数组； 当只有一个参数时，如果该参数为数字，则创建一个包含给定项数的数组，否则创建一个包含那个值的数组； 当参数为多个时，创建包含给定参数的数组。 1let colors = new Array('red','green'); 字面量方式字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开。 1let colors = ['red','green']; 属性length属性数组的length属性可以获取数组的项数，并且可以通过给该属性赋值来改变数组的项数。 方法Array.from()Array.from 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map） 语法1Array.from(arrayLike, mapFn, thisArg) 参数 arrayLike：想要转换成数组的伪数组对象或可迭代对象。 mapFn (可选参数)：如果指定了该参数，新数组中的每个元素会执行该回调函数。 thisArg (可选参数)：可选参数，执行回调函数 mapFn 时 this 对象。 返回值一个新的数组实例 1let a = Array.from('123', value =&gt; Number.parseInt(value) + 3); // [4, 5, 6] Array.isArray()Array.isArray() 用于确定传递的值是否是一个 Array。 语法1Array.isArray(obj) 参数 obj：需要检测的值。 返回值返回一个布尔值：如果对象是 Array，则为true; 否则为false。 12Array.isArray([1]); // trueArray.isArray(&#123;&#125;); // false Array.of()Array.of() 方法创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 语法1Array.of(element0[, element1[, ...[, elementN]]]) 参数 elementN：任意个参数，将按顺序成为返回数组中的元素。 返回值新的 Array 实例","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://langliu.github.io/tags/JavaScript/"}]},{"title":"JavaScript的this指向问题","slug":"JavaScript的this指向问题","date":"2017-10-18T23:28:16.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/10/18/JavaScript的this指向问题/","link":"","permalink":"https://langliu.github.io/2017/10/18/JavaScript的this指向问题/","excerpt":"和许多常见的其他语言不一样，JavaScript的 this 指向不是在定义时就确定了的，而是在调用时确定的。 指向全局指向在严格模式下，默认的 this 指向 undefined ，在非严格模式下，默认的 this 指向 window","text":"和许多常见的其他语言不一样，JavaScript的 this 指向不是在定义时就确定了的，而是在调用时确定的。 指向全局指向在严格模式下，默认的 this 指向 undefined ，在非严格模式下，默认的 this 指向 window 12345let x = 1;function test() &#123; console.log(this.x);&#125;test(); // 严格模式下为： undefined ；非严格模式为： 1 对象内部的指向如果 this 是在对象内部定义的，一般来说 this 指向 this 定义时的上一级对象 1234567let obj = &#123; name: \"Allen\", getName: function() &#123; console.log(this.name); &#125;&#125;;obj.getName(); // 'Allen' 12345678910let obj = &#123; name: \"Allen\", getName: &#123; name: \"Youngor\", fn: function() &#123; console.log(this.name); &#125; &#125;&#125;;obj.getName.fn(); // 'Youngor' 在上面的例子中，第一个例子的 this 指向对象 obj ，第二个例子的 this 指向对象 obj 的属性 getName（因为该属性也是一个对象），如果 getName 属性中不存在对象属性 name ，那么 this.name 则为 undefined ，this 并不会在向上一级寻找。 有一种情况有点特殊，需要我们注意下： 1234567891011let obj = &#123; name: \"Allen\", getName: &#123; name: \"Youngor\", fn: function() &#123; console.log(this.name); &#125; &#125;&#125;;let fn = obj.getName.fn;fn(); // undefined 我们发现结果和我们预期的有点不一样，这是为什么呢？我们需要记住这句话 this永远指向的是最后调用它的对象 ，在上面的例子中，我们把 obj.getName.fn 赋值给一个变量 fn ，通过这个变量来执行this，这时候最后调用它的对象已经从对象 obj 的属性 getName 变为全局对象了，所以执行的结果是 undefined。 构造函数中的this12345678function Person() &#123; this.name = \"Allen\"; this.age = 21;&#125;let person = new Person();console.log(person.name); // 'Allen'console.log(person.age); // 21 new 关键字可以改变 this 的指向，将其指向新建的对象，在这里指向 person 对象 当 this 遇见 return1234567function fun() &#123; this.name = \"Allen\"; return 1;&#125;let f = new fun();console.log(f.name); // 'Allen' 1234567function fun() &#123; this.name = \"Allen\"; return &#123;&#125;;&#125;let f = new fun();console.log(f.name); // undefined 如果返回值是一个对象，那么this指向的就是那个返回的对象（null除外）；如果返回值不是一个对象，那么this指向的还是那个函数的实例。 箭头函数中的 this函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 bind、apply、call对this的影响bindbind() 的作用是将当前函数与指定的对象绑定，并返回一个新的函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象。 1234567891011function test() &#123; console.log(this.name);&#125;let obj1 = &#123; name: 'hi'&#125;;let fun = test.bind(obj1); // 第一次bindfun(); // 'hi'fun.bind(&#123;name: 'srd'&#125;); // 第二次bindfun(); // 'hi' callcall() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。 1234function fun() &#123; console.log(this.name);&#125;fun.call(&#123; name: \"Allen\" &#125;); // 'Allen' applyapply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。 1234function fun() &#123; console.log(this.name);&#125;fun.apply(&#123; name: \"Allen\" &#125;); // 'Allen'","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://langliu.github.io/tags/JavaScript/"}]},{"title":"配置CentOS云端NodeJS环境","slug":"配置CentOS云端NodeJS环境","date":"2017-10-14T23:35:25.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/10/14/配置CentOS云端NodeJS环境/","link":"","permalink":"https://langliu.github.io/2017/10/14/配置CentOS云端NodeJS环境/","excerpt":"最近买了一个阿里云的云服务器，想要把自己的项目部署到阿里云上可以通过外网访问，阿里云上配置环境的时候有许多的不懂的地方，这是我配置环境的步骤，将此记下来：","text":"最近买了一个阿里云的云服务器，想要把自己的项目部署到阿里云上可以通过外网访问，阿里云上配置环境的时候有许多的不懂的地方，这是我配置环境的步骤，将此记下来： 安装 Nginx在 CentOS 上，可直接使用 yum 来安装Nginx： 1yum install nginx -y 安装完成后，使用 nginx 命令启动 Nginx： 1nginx 此时，访问 http://IP 可以看到 Nginx 的测试页面。 如果此时不能访问，则是因为云服务器 ECS 未开放80端口，不能通过公网访问80端口，此时进入 管理控制台/云服务器ECS/网络和安全/安全组 添加一个新的规则，使之能够通过公网访问80端口，如果需要暴露其他端口，同样需要在安全组中配置安全规则。 配置静态服务器访问路径外网用户访问服务器的 Web 服务由 Nginx 提供，Nginx 需要配置静态资源的路径信息才能通过 url 正确访问到服务器上的静态资源。 打开 Nginx 的默认配置文件 /etc/nginx/nginx.conf ，修改 Nginx 配置，将默认的 root /usr/share/nginx/html; 修改为: root /data/www;，如下：nginx.conf 配置文件将 /data/www/static 作为所有静态资源请求的根路径，如访问: http://IP/static/index.js，将会去 /data/www/static/ 目录下去查找 index.js。现在我们需要重启 Nginx 让新的配置生效，如： 1nginx -s reload 重启后，现在我们应该已经可以使用我们的静态服务器了，现在让我们新建一个静态文件，查看服务是否运行正常。 首先让我们在 /data 目录 下创建 www 目录，如： 1mkdir -p /data/www 创建第一个静态文件在 /data/www 目录下创建我们的第一个静态文件 index.html： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;link href=\"css/style.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 现在访问 http://IP/index.html 应该可以看到页面输出 Hello world! 到此，一个基于 Nginx 的静态服务器就搭建完成了，现在所有放在 /data/www 目录下的的静态资源都可以直接通过域名访问。 安装最新版 git在 CentOS 下可以使用 yum 命令直接安装 git ：yum install git，但是因为 yum 仓库的源比较旧，所以安装的 git 版本比较老，我最近使用 yum 安装的 git 的版本为 1.8.3 ，而最新的版本为 2.14.2 ，版本差了太多了。 部署Node.js环境 - 使用NVM安装多版本NVM（Node version manager）是Node.js的版本管理软件，使用户可以轻松在Node.js各个版本间进行切换。适用于长期做 node 开发的人员或有快速更新node版本、快速切换node版本这一需求的用户。 安装步骤： 1、直接使用git将源码克隆到本地的~/.nvm目录下，并检查最新版本。 12yum install gitgit clone https://github.com/cnpm/nvm.git ~/.nvm &amp;&amp; cd ~/.nvm &amp;&amp; git checkout `git describe --abbrev=0 --tags` 2、激活NVM。 12echo &quot;. ~/.nvm/nvm.sh&quot; &gt;&gt; /etc/profilesource /etc/profile 3、列出Node.js的所有版本。 1nvm list-remote 4、安装多个Node.js版本。 12nvm install v6.11.4nvm install v8.7.0 5、查看已安装Node.js版本，当前使用的版本为v8.7.0。 123[root@iZuf62didsxigy36d6kjtrZ .nvm]# nvm ls-&gt; v6.11.4 v8.7.0 6、切换Node.js版本至v6.11.4。 12[root@iZuf62didsxigy36d6kjtrZ .nvm]# nvm use v6.11.4Now using node v6.11.4 安装进程管理器安装进程管理器以便控制Node.js应用程序，这个进程管理器可以保持应用程序一直在运行，运行以下命令进行安装： 1[root@localhost ~]# npm install pm2 -g 使用pm2启动进程1pm2 start app.js // 该命令会保证 app.js 一直在后台运行 查看所有进程1pm2 list // 该命令会列出所有在后台运行的进程 安装Mongodb配置包管理系统（yum）创建一个/etc/yum.repos.d/mongodb-org-3.4.repo文件，使您可以直接安装MongoDB。在文件中写入下面内容： 123456[mongodb-org-3.4]name=MongoDB Repositorybaseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/3.4/x86_64/gpgcheck=1enabled=1gpgkey=https://www.mongodb.org/static/pgp/server-3.4.asc 安装MongoDB软件包和相关工具。要安装最新的稳定版本的MongoDB，请发出以下命令： 1sudo yum install -y mongodb-org 数据目录和权限MongoDB实例默认存储其数据文件/var/lib/mongo 及其日志文件/var/log/mongodb，并使用mongod 用户帐户运行。您可以在其中指定备用日志和数据文件目录/etc/mongod.conf。查看systemLog.path 和storage.dbPath获取更多信息。 如果更改运行MongoDB进程的用户，则 必须修改对/var/lib/mongo和 /var/log/mongodb目录的访问控制权限，以使该用户能够访问这些目录。 操作启动MongoDB。您可以mongod通过发出以下命令来启动该过程： 1sudo service mongod start 验证MongoDB已经成功启动您可以mongod通过检查日志文件的内容进行/var/log/mongodb/mongod.log 读取来验证进程是否成功启动 1[initandlisten] waiting for connections on port &lt;port&gt; 其中被配置为在该端口/etc/mongod.conf，27017默认情况下。 停止MongoDB。根据需要，您可以mongod通过发出以下命令来停止进程： 1sudo service mongod stop 重新启动MongoDB。您可以mongod通过发出以下命令重新启动该过程： 1sudo service mongod restart 您可以通过查看/var/log/mongodb/mongod.log文件中的输出来跟踪进程的状态，以查找错误或重要消息。 查看端口号1netstat -anl|grep &quot;端口号&quot;","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://langliu.github.io/categories/环境配置/"}],"tags":[]},{"title":"前端跨域问题","slug":"前端跨域问题","date":"2017-10-12T22:33:38.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/10/12/前端跨域问题/","link":"","permalink":"https://langliu.github.io/2017/10/12/前端跨域问题/","excerpt":"最近面试一直有被问到关于跨域的问题，自己了解的也不多，只知道可以通过jsonp可以解决，但对其具体怎么解决的却不太了解，于是花了一点时间专门研究了一下这个问题。 什么是跨域首先什么是跨域呢？协议、域名、端口都相同是同源，否则都是跨域。","text":"最近面试一直有被问到关于跨域的问题，自己了解的也不多，只知道可以通过jsonp可以解决，但对其具体怎么解决的却不太了解，于是花了一点时间专门研究了一下这个问题。 什么是跨域首先什么是跨域呢？协议、域名、端口都相同是同源，否则都是跨域。 解决跨域的一些方法图像Ping一个网页可以从任何网页中加载图像，不用担心跨域不跨域。图像Ping就是利用 &lt;img&gt; 标签来与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容。通过图像Ping，浏览器得不到任何具体的数据，但可以监听 load 和 error 事件知道响应是什么时候接收到的。 12345let img = new Image();img.onload = img.onerror = function() &#123; console.log('Done');&#125;;img.src = 'http://www.example.com/test?name=Allen'; 缺点 只能发送GET请求 无法访问服务器的响应文本 JSONPJSONP是JSON with padding（填充式JSON）的简写，是应用JSON的一种新方法。通过动态创建 &lt;script&gt; 标签来使用，使用时可以为其 src 属性指定一个跨域的URL。 JSONP由两部分组成： 回调函数：当响应到来时在页面中调用的函数（回调函数的名字一般在请求中指定） 数据：传入回调函数中的JSON数据 1234567function handleResponse(response) &#123; console.log(response);&#125;let script = document.createElement('script');script.src = 'http://freegeoip.net/json/?callback=handleResponse';document.body.insertBefore(script,document.body.firstChild); 缺点 如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP调用之外，没有办法追究。 跨域资源共享CORS(Cross-Origin Resource Rharing)背后的思想是浏览器和服务端通过头部信息来进行沟通确认是否给予响应。如： 1234Origin: http://www.baidu.com // 浏览器的头部信息// 如果服务端认可这个域名的跨域请求，如下设置就可跨域访问资源Access-Control-Allow-Origin: http://www.baidu.com 如上就可以实现最简单的跨域访问，但是此时不能携带任何的cookie，如果我们需要传递cookie进行身份认证，需要设置： 12xhr.withCredentials = true; // 浏览器端Access-Control-Allow-Credentials: true; // 服务端 这样我们就可以传递认证信息了，但如果允许认证，Access-Control-Allow-Origin不能设置为*，而一定是具体的域名信息。 html5 postMessage方法html5引入的message的API可以更方便、有效、安全的解决跨域问题。postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 postMessage(data,origin)方法接受两个参数： data:要传递的数据，html5规范中提到该参数可以是JavaScript的任意基本类型或可复制的对象，然而并不是所有浏览器都做到了这点儿，部分浏览器只能处理字符串参数，所以我们在传递参数的时候需要使用JSON.stringify()方法对对象参数序列化。 origin：字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为”*”，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 发送消息123window.onload = function() &#123; window.frames[0].postMessage(\"getcolor\", \"http://lslib.com\");&#125;; 接受消息通过监听 message 事件来获取传入的消息： 123456789window.addEventListener( \"message\", function(e) &#123; if (e.source != window.parent) return; let color = container.style.backgroundColor; window.parent.postMessage(color, \"*\"); &#125;, false); 传入的消息有几个重要属性： data：顾名思义，是传递来的message source：发送消息的窗口对象 origin：发送消息窗口的源（协议+主机+端口号）","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://langliu.github.io/tags/JavaScript/"}]},{"title":"浏览器内核","slug":"浏览器内核","date":"2017-09-25T16:56:16.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/09/25/浏览器内核/","link":"","permalink":"https://langliu.github.io/2017/09/25/浏览器内核/","excerpt":"前几天面试的时候面试官问到了关于浏览器内核的问题，当时他问的是有哪几种浏览器内核，但是我只知道WebKit一种，后来面试结束后一直想着这个问题，然后在网上了解了以下，下面是一些结果：","text":"前几天面试的时候面试官问到了关于浏览器内核的问题，当时他问的是有哪几种浏览器内核，但是我只知道WebKit一种，后来面试结束后一直想着这个问题，然后在网上了解了以下，下面是一些结果： 定义浏览器最重要或者说核心的部分是“Rendering Engine”，可大概译为“渲染引擎”，不过我们一般习惯将之称为“浏览器内核”。负责对网页语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。 分类WebkitWebkit(Safari内核,Chrome内核原型,开源):它是苹果公司自己的内核，也是苹果的Safari浏览器使用的内核。 Webkit引擎包含WebCore排版引擎及JavaScriptCore解析引擎，均是从KDE的KHTML及KJS引擎衍生而来，它们都是自由软件，在GPL条约下授权，同时支持BSD系统的开发。所以Webkit也是自由软件，同时开放源代码。在安全方面不受IE、Firefox的制约，所以Safari浏览器在国内还是很安全的。 Webkit浏览器：Chrome、Safari、Opera TridentTrident(IE内核)：该内核程序在1997年的IE4中首次被采用，是微软在Mosaic代码的基础之上修改而来的，并沿用到IE11，也被普遍称作”IE内核”。Trident实际上是一款开放的内核，其接口内核设计的相当成熟，因此才有许多采用IE内核而非IE的浏览器(壳浏览器)涌现。 由于IE本身的“垄断性”（虽然名义上IE并非垄断，但实际上，特别是从Windows 95年代一直到XP初期，就市场占有率来说IE的确借助Windows的东风处于“垄断”的地位）而使得Trident内核的长期一家独大，微软很长时间都并没有更新Trident内核，这导致了两个后果——一是Trident内核曾经几乎与W3C标准脱节（2005年），二是Trident内核的大量 Bug等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为IE浏览器不安全的观点，也有很多用户转向了其他浏览器，Firefox和Opera就是这个时候兴起的。非Trident内核浏览器的市场占有率大幅提高也致使许多网页开发人员开始注意网页标准和非IE浏览器的浏览效果问题。 Trident内核的常见浏览器有：[1] IE6、IE7、IE8（Trident 4.0）、IE9（Trident 5.0）、IE10（Trident 6.0）；360安全浏览器（1.0-5.0为Trident，6.0为Trident+Webkit，7.0为Trident+Blink）猎豹极轻浏览器，360极速浏览器（7.5之前为Trident+Webkit，7.5为Trident+Blink）猎豹安全浏览器（1.0-4.2版本为Trident+Webkit，4.3及以后版本为Trident+Blink）猎豹极轻浏览器，傲游浏览器（傲游1.x、2.x为IE内核，3.x为IE与Webkit双核）、百度浏览器（早期版本）、搜狗高速浏览器（1.x为Trident，2.0及以后版本为Trident+Webkit）、UC浏览器（Blink内核+Trident内核）等。 其中部分浏览器的新版本是“双核”甚至是“多核”，其中一个内核是Trident，然后再增加一个其他内核。国内的厂商一般把其他内核叫做“高速浏览模式”，而Trident则是“兼容浏览模式”，用户可以来回切换。 GeckoGecko(Firefox内核)：Netscape6开始采用的内核，后来的Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko内核的浏览器也很多，这也是Gecko内核虽然年轻但市场占有率能够迅速提高的重要原因。 事实上，Gecko引擎的由来跟IE不无关系，前面说过IE没有使用W3C的标准，这导致了微软内部一些开发人员的不满；他们与当时已经停止更新了的 Netscape的一些员工一起创办了Mozilla，以当时的Mosaic内核为基础重新编写内核，于是开发出了Gecko。不过事实上，Gecko 内核的浏览器仍然还是Firefox (火狐) 用户最多，所以有时也会被称为Firefox内核。此外Gecko也是一个跨平台内核，可以在Windows、 BSD、Linux和Mac OS X中使用。 补充：JavaScript引擎是SpiderMonkey。 Gecko内核常见的浏览器：[1] Mozilla Firefox、Mozilla SeaMonkey、waterfox（Firefox的64位开源版）、Iceweasel、Epiphany（早期版本）、Flock（早期版本）、K-Meleon BlinkBlink是一个由Google和Opera Software开发的浏览器排版引擎，Google计划将这个渲染引擎作为Chromium计划的一部分，并且在2013年4月的时候公布了这一消息。这一渲染引擎是开源引擎WebKit中WebCore组件的一个分支，并且在Chrome（28及往后版本）、Opera（15及往后版本）和Yandex浏览器中使用。 EdgeHTMLEdgeHTML，是微软网页浏览器Microsoft Edge所使用的网页排版引擎(以下简称内核)的名称。由微软在原IE浏览器的Trident内核基础上，删除了过时的旧技术支持代码，增加了对现代浏览器技术的支持，是一个全新的内核。初始版作为Windows 10 9926预览版的IE11内核，此后每一个Windows 10预览版的IE11和Project Spartan(Microsoft Edge尚未正式命名时的)都同时用EdgeHTML作为内核。 ChromiumChromium是一个由Google主导开发的网页浏览器，以BSD许可证等多重自由版权发行并开放源代码。Chromium的开发可能早自2006年即开始，设计思想基于简单、高速、稳定、安全等理念，在架构上使用了苹果发展出来的WebKit排版引擎、Safari的部份源代码与Firefox的成果，并采用Google独家开发出的V8引擎以提升解译JavaScript的效率，而且设计了“沙盒”、“黑名单”、“无痕浏览”等功能来实现稳定与安全的网页浏览环境。","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"前端工具","slug":"前端工具","permalink":"https://langliu.github.io/tags/前端工具/"}]},{"title":"Python入门","slug":"Python入门","date":"2017-09-24T23:56:51.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/09/24/Python入门/","link":"","permalink":"https://langliu.github.io/2017/09/24/Python入门/","excerpt":"近两年Python很火，最近闲着没什么事干，于是也想学一下 Python，了解一门后端语言。 简介优缺点学习一门语言，首先就要知道这门语言的优缺点及适用领域，只有了解了这些之后，才能更好地使用这门语言，那么下面就说一下Python的优缺点及适用领域：","text":"近两年Python很火，最近闲着没什么事干，于是也想学一下 Python，了解一门后端语言。 简介优缺点学习一门语言，首先就要知道这门语言的优缺点及适用领域，只有了解了这些之后，才能更好地使用这门语言，那么下面就说一下Python的优缺点及适用领域： 优点： 代码简单、优雅 完善的基础代码库：Python为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。 缺点： 运行速度慢：因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。 代码不能加密 适用领域： 网络应用，包括网站、后台服务等等 许多日常需要的小工具，包括系统管理员需要的脚本任务等等 把其他语言开发的程序再包装起来，方便使用 Python基础语法Python的语法比较简单，采用缩进方式，写出来的代码就像下面的样子： 123456# print absolute value of an integer:a = 100if a &gt;= 0: print(a)else: print(-a) 注释Python对代码的注释是以 # 为标志的语句，在Python代码执行的时候， # 后面的语句会自动忽略： 123# 这是注释name = 'allen' # 姓名print(name) 代码块因为Python采用缩进方式，所以不像其他语言那样按照 {} 内的内容算一个代码块，Python按不同的缩进分为不同的代码块，当语句以冒号:结尾时，缩进的语句视为代码块。 数据类型Python是一门弱类型的语言，声明时不需要显示指定变量的类型，Python有以下基础类型： 整数 浮点数 字符串 在使用字符串的时候，有时候我们需要使用一些特殊的字符而不希望其被转义，这时我们可以使用 r&#39;&#39; 表示&#39;&#39;内部的字符串默认不转义 如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用&#39;&#39;&#39;...&#39;&#39;&#39;的格式表示多行内容 布尔值 (True, False) and 运算：and运算是与运算，只有所有都为True，and运算结果才是True or运算：or运算是或运算，只要其中有一个为True，or运算结果就是True not运算：not运算是非运算，它是一个单目运算符，把True变成False，False变成True 空值 (None) 变量和常量 变量：变量以数字、字母和下划线组成，且不能以数字开头 常量：常量以全部大写的变量名表示 除法在Python中，有两种除法，一种除法是/： 12&gt;&gt;&gt; 10 / 33.3333333333333335 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 12&gt;&gt;&gt; 9 / 33.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数： 12&gt;&gt;&gt; 10 // 33 你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。 输入和输出对于一门语言来说，输入和输出是最基础的语法，在很多地方都会用到： 输入：Python提供了一个从命令行获取输入的内置方法 input(placeholder) ，该方法有零个或一个参数，参数为用户输入的提示信息： 12name = input('请输入姓名：') # 姓名print(name) 输出：print() 方法可以用来输出，该方法可以接受一个或多个值，当接受多个值时每个值以 , 分隔，在输出的时候，遇见 , 则会将其转换为空格 字符编码在最新的Python 3版本中，字符串是以Unicode编码的。对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符： 12345678&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; ord('中')20013&gt;&gt;&gt; chr(66)'B'&gt;&gt;&gt; chr(25991)'文' 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 Python对bytes类型的数据用带b前缀的单引号或双引号表示： 1x = b'ABC' 以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如： 1234&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\\xe4\\xb8\\xad\\xe6\\x96\\x87' 格式化我们经常会输出类似&#39;亲爱的xxx你好！你xx月的话费是xx，余额是xx&#39;之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。 常见的占位符有： 占位符 表示 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数： 1234&gt;&gt;&gt; '%2d-%02d' % (3, 1)' 3-01'&gt;&gt;&gt; '%.2f' % 3.1415926'3.14' 有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%： 12&gt;&gt;&gt; '所在专业排名： %d%%-%d%%' % (5, 20)'所在专业排名： 5%-20%' 列表Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。（同其他语言的数组相似） 一个列表： 1names = ['allen', 'jhon', 'toy'] 访问列表元素用索引来访问list中每一个位置的元素，索引从0开始，当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界。如果要从最后一个元素像前访问，可以以负数做索引，如最后一个元素的索引为-1 ，倒数第二个元素的索引为 -2 12names[1] # allennames[-1] # toy 添加元素到末尾1names.append('young') 把元素插入到指定的位置1names.insert(1, 'Tom') 删除list末尾的元素1names.pop() 删除指定位置的元素1names.pop(2) 元组tuple和list非常类似，但是tuple一旦初始化就不能修改，一个姓名的元组： 1names = ('Allen', 'Youngor') 元组同样可以通过索引访问： 1names[0] # 'Allen' 有一个地方需要注意，如果你想创建一个只有一个元素的元组，那么在定义的时候需要小心，你应该这么定义： 1name = ('Allen',) 注意最后的逗号，如果没有逗号的话就不是一个元组了，Python会将其进行运算，转换成一个字符串 条件判断12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 循环for…in循环for…in循环，依次把list或tuple中的每个元素迭代出来： 123names = ['Michael', 'Bob', 'Tracy']for name in names: print(name) 如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数： 1list(range(5)) # [0, 1, 2, 3, 4] while循环while循环，只要条件满足，就不断循环，条件不满足时退出循环。 1234567n = 1while n &lt;= 100: if n &gt; 10: # 当n = 11时，条件满足，执行break语句 break # break语句会结束当前循环 print(n) n = n + 1print('END') 字典Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 一个姓名-成绩的字典： 1d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125; 如果key不存在，dict就会报错，有两种方式可以判断key是否存在： in ：&#39;Bob&#39; in d get(key, default) ：如果key不存在，可以返回None，或者自己指定的value 删除一个key：1d.pop('Bob) 和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。 setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 一个set： 12names = ['Allen', 'Youngor']s = set(names) # &#123;'Allen', 'Youngor'&#125; 添加元素1s.add('John') # &#123;'Allen', 'Youngor', 'John'&#125; 删除元素1s.remove('Allen') # &#123;'Youngor', 'John'&#125; set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： 12345678&gt;&gt;&gt; s1 = set([1, 2, 3, 4])&gt;&gt;&gt; s2 = set([2, 3])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s1 - s2&#123;1, 4&#125; 数据类型转换 int() str() float() bool() 函数函数声明在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 一个求绝对值的函数： 12345def my_abs(x): if x &gt;= 0: return x else: return -x 空函数如果想定义一个什么事也不做的空函数，可以用pass语句： 12def nop(): pass 参数检查调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError 返回多个值函数可以返回多个值吗？答案是肯定的。 比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的新的坐标： 123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny import math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。 然后，我们就可以同时获得返回值： 1x, y = move(100, 100, 60, math.pi / 6) 默认参数123def pow(n, m=2, age=22): print('age: %d' % age) return n + m 使用123pow(3) # 5pow(3, 6) # 9pow(3, age=34) # 5 可变参数123456789101112def calc(*numbers): s = 0 print(numbers[0]) print(numbers[1]) print(numbers[2]) for n in numbers: s += n * n return ss = calc(1, 2, 3)print(s)","categories":[{"name":"Python","slug":"Python","permalink":"https://langliu.github.io/categories/Python/"}],"tags":[{"name":"Python语法","slug":"Python语法","permalink":"https://langliu.github.io/tags/Python语法/"}]},{"title":"Ajax技术","slug":"Ajax技术","date":"2017-09-22T22:27:20.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/09/22/Ajax技术/","link":"","permalink":"https://langliu.github.io/2017/09/22/Ajax技术/","excerpt":"什么是Ajax？AJAX = 异步 JavaScript 和 XML。 AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。","text":"什么是Ajax？AJAX = 异步 JavaScript 和 XML。 AJAX 是一种用于创建快速动态网页的技术。 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 一个简单的Ajax请求12345678910let xhr = new XMLHttpRequest();xhr.open('get', 'data.json', true);xhr.send();xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; console.log(xhr.responseText); &#125; &#125;&#125;; 创建 XMLHttpRequest 对象XMLHttpRequest 是 AJAX 的基础。所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。 现代浏览器：const xhr = new XMLHttpRequest(); IE5和IE6：const xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 123456// Old compatibility code, no longer needed.if (window.XMLHttpRequest) &#123; // Mozilla, Safari, IE7+ ... httpRequest = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; // IE 6 and older httpRequest = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125; XMLHttpRequest 的用法open()在使用 XMLHttpRequest 对象的时候，要调用的第一个方法就是 open(method, url, async) ，该方法接受三个参数： method：要发送的请求的类型 // “get”、”post” 等 url：请求的URL（请求的url中如果有中文会报错，所以如果要使用中文要对参数重新使用 encodeURI() 编码） async：是否异步发送请求的布尔值 setRequestHeader()setRequestHeader(header, value) 用于设置请求头 send()send(message) 方法接受一个参数，即要作为请求主体发送的数据。如果是 get 方法，则不发送数据。 获取传回的数据要获取返回的数据要知道请求现在处于什么状态，可以使用 onreadystatechange 来监听请求状态的变化，然后通过检测 readyState 属性的值来判断请求现在的状态 readyState 属性有5个值： 0：XMLHttpRequest对象创建完成 1：XMLHttpRequest对象初始化完成 2：请求已经发送 3：服务器已经返回了数据（数据还未被解析，可能只是一段http报文） 4：数据解析已经完成 进度事件XMLHttpRequest 提供了各种在请求被处理期间发生的事件以供监听。这包括定期进度通知、 错误通知，等等。 loadstart：在接收到响应数据的第一个字节时触发 progress：在收到响应期间持续不断地触发 error：在请求发生错误时触发 abort：在因为调用abort方法而中断请求时触发 onload：在接收到完整的响应数据时触发 loadend：在通信完成或触发error、abort、或load事件后触发 使用进度事件可以代替 onreadystatechange 来监听请求状态的变化，例如上面的例子我们可以改写成： 12345678let xhr = new XMLHttpRequest();xhr.open('get', 'data.json', true);xhr.send();xhr.onload = () =&gt; &#123; if (xhr.status === 200) &#123; console.log(xhr.responseText); &#125;&#125;; 服务器响应当请求信息发送之后，请求就会被分派到服务器。在服务器响应后，会将响应数据自动填充到XHR对象的属性中，相关属性如下： responseText ：作为响应主体被返回的文本（JSON格式） responseXML ：如果响应的内容类型是 text/xml 或 application/xml ，这个属性中将保存着响应数据的XML DOM文档（XML格式） status ：响应的HTTP状态（200：成功；404：页面不存在；503：页面存在，但有语法错误） statusText ：HTTP状态的说明 GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 GET 和 POST 的差别GET请求 将表单数据以名/值对的形式附加到URL中（数据是可见的，不能用于提交敏感数据） URL的长度是有限的（大约3000字符） GET请求会被浏览器主动缓存 GET产生一个TCP数据包（对于GET方式的请求，浏览器会把HTTP header 和 data 一并发送出去，服务器响应200） POST请求 将表单数据附加到HTTP请求的body内 没有长度限制 POST请求不会被浏览器主动缓存 通过POST请求提交的表单不能加入书签 POST产生两个TCP数据包（对于POST方式的请求，浏览器先发送HTTP header，服务器响应100， 浏览器再发送data，服务器响应200）","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://langliu.github.io/tags/JavaScript/"}]},{"title":"Jasmine——行为驱动开发","slug":"Jasmine——行为驱动开发","date":"2017-09-18T21:39:25.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/09/18/Jasmine——行为驱动开发/","link":"","permalink":"https://langliu.github.io/2017/09/18/Jasmine——行为驱动开发/","excerpt":"Jasmine是测试 JavaScript 代码行为驱动开发框架。它并不取决于任何其他 JavaScript 框架。它不需要 dom。它有清洁、 明显的语法，使您可以轻松编写测试。","text":"Jasmine是测试 JavaScript 代码行为驱动开发框架。它并不取决于任何其他 JavaScript 框架。它不需要 dom。它有清洁、 明显的语法，使您可以轻松编写测试。 安装123npm install jasmine --save-dev // 安装到项目npm install jasmine --global // 全局安装 初始化一个项目1./node_modules/.bin/jasmine 配置1234567891011&#123; \"spec_dir\": \"spec\", // spec所在目录 \"spec_files\": [ \"**/*[sS]pec.js\" // 测试文件（以[sS]pec.js结尾的js文件，可以自己更改后缀名） ], \"helpers\": [ \"helpers/**/*.js\" // 测试前辅助文件，相对于spec_dir ], \"stopSpecOnExpectationFailure\": false, \"random\": false&#125; 运行测试123jasmine // 根据配置运行所有的测试jasmine spec/test.spec.js // 运行某个测试 编写测试代码上面我们已经成功将Jasmine安装到我们的项目中了，现在我们可以开始编写单元测试的代码了 一个最基本的单元测试代码： 12345describe(\"A suite\", function() &#123; it(\"contains spec with an expectation\", function() &#123; expect(true).toBe(true); &#125;);&#125;); 每个测试都在一个测试集中运行，Suite就是一个测试集，用describe函数封装。 Spec表示每个测试用例，用it函数封装。通过expect函数，作为程序断言来判断相等关系。 describe 函数包含两个参数： string name 一个测试套件的名称 function fn 实现测试套件的代码块 it 函数定义两个参数： string name spec的标题 function fn spec的函数 expect 函数 接收一个 value , 返回一个链式匹配对象拥有以下匹配规则函数： toBe // 引用全等 ‘===’ toEqual // 深度遍历，值全等 toMatch // 正则匹配，支持字符串和正则表达式 toContain // 判断字符串或数组中是否包含某个字符或元素 toBeNull // === null toBeDefined // expect !== undefined toBeUndefined // expect === undefined toBeTruthy // Boolean(expect) === true toBeFalsy // Boolean(expect) === false toBeLessThan // expect的参数小于 &lt; value；expect(2).toBeLessThan(3); toBeGreaterThan // expect的参数大于 &gt; value toBeCloseTo // value - precision &lt;= expect &lt; value + precision；expect(3.1415926).toBeCloseTo(2.78, 0); toThrow // expect throw ‘xx’ toThrowError // expect throw type or match error message 一个suite 可以有多个 describe, 一个 describe 可以有多个 it, 一个it 可以有多个 expect fail函数fail 函数, 直接指定spec的错误原因： 12345678describe(\"A suite is just a function\", function () &#123; let a; it(\"and so is a spec\", function () &#123; a = true; expect(1).toBe('1'); fail('两个值并不全等'); &#125;);&#125;); 在上面的测试代码中，通过fail函数将测试不通过的原因指定为我们自定义的信息，如果为添加 fail 函数，Jasmine将会使用框架提供的提示，像下面这样： Expected 1 to be &#39;1&#39;.；而如果使用了 fail 函数，错误的提示信息将会变为： 两个值并不全等 not任何匹配表达式都可以有 not 前缀对象， 表示与期待的相反. 如： 12345describe('a suite', function () &#123; it('should not equal false if expect is true', function () &#123; expect(true).not.toBe(false); &#125;);&#125;); 挂起的测试如果我们写了某个测试规则，但不想让这个测试跑的话，我们有三种方式可以实现： 需要将该规则的声明关键字变为 xit ，这样该测试规则在测试运行的时候就会被忽略。 使用 it 声明，但是没有函数体 在规则内部使用 pending() 声明 12345678910describe(\"Pending specs\", function () &#123; xit(\"can be declared 'xit'\", function () &#123; expect(true).toBe(false); &#125;); it(\"can be declared with 'it' but without a function\"); it(\"can be declared by calling 'pending' in the spec body\", function () &#123; expect(true).toBe(false); pending('this is why it is pending'); &#125;);&#125;); 更多更多的内容可以参考Jasmine的官方说明： https://jasmine.github.io/edge/introduction.html","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"前端工具","slug":"前端工具","permalink":"https://langliu.github.io/tags/前端工具/"}]},{"title":"Babel的使用","slug":"Babel的使用","date":"2017-09-17T15:35:09.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/09/17/Babel的使用/","link":"","permalink":"https://langliu.github.io/2017/09/17/Babel的使用/","excerpt":"ES2015出来已经有好几年了，但是到今天为止，所有的ES2015的语法并没有被全部支持，那么ES2015的语法是不是就不能使用不支持的那些呢？不是的，我们完全可以在我们的代码里面使用所有的ES2015的语法，只要我们配置了Babel。","text":"ES2015出来已经有好几年了，但是到今天为止，所有的ES2015的语法并没有被全部支持，那么ES2015的语法是不是就不能使用不支持的那些呢？不是的，我们完全可以在我们的代码里面使用所有的ES2015的语法，只要我们配置了Babel。 bable-cli安装1npm install --save-dev babel-cli 编译单个文件如果你想编译某个文件并且输出编译后的结果到另一个文件，我们可以使用 --out-file 或者 -o 参数： 1babel script.js --out-file script-compiled.js 如果每次改变文件都想它自动编译并输出，我们需要在编译的时候添加 --watch 或者 -w 参数： 1babel script.js --watch --out-file script-compiled.js 编译整个目录中的文件对于写项目来说，如果文件需要一个一个的编译那么太麻烦了，有可能一个项目中有成百上千个文件，这时我们就需要使用Babel提供的按文件夹编译： 1babel src --out-dir lib 执行上面的命令后，babel会将src文件夹下面的所有文件按照目录结构编译到lib文件夹下，你可以在lib文件夹中看见和src文件夹中一样的目录结构，只不过lib文件夹下的所以文件都是编译后的结果。 将整个目录的文件输出到一个文件： 1babel src --out-file script-compiled.js 忽略文件有时候在我们的代码中有一些测试文件或其他的文件我们并不需要编译，那么这时候我们就可以使用 --ignore + &lt;filename&gt; 来忽略这些文件： 1babel src --out-dir lib --ignore spec.js,test.js 在上面的代码中，我们就忽略了src文件夹下的以spec.js和test.js结尾的文件，比如main.spec.js、main.test.js，当然如果你的文件夹下有spec.js和test.js这两个文件，babel也会将其忽略。 babel-node我们运行js的时候使用的命令是 node &lt;filename&gt; ，如果你的js代码中使用了nodejs暂时还未支持的语法，则代码会报错。这时，Babel提供给我们了一个 babel-node 命令，你可使用 babel-node 命令替换 node 命令直接运行ES2015的代码，而不需要将其编译成ES5的语法后运行编译后的代码。 .babelrcBabel的配置文件是.babelrc，存放在项目的根目录下。该文件用来设置转码规则和插件，基本格式如下。 1234&#123; \"presets\": [], \"plugins\": []&#125; presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 12345# ES2015+转码规则$ npm install babel-preset-env --save-dev# react转码规则$ npm install --save-dev babel-preset-react 安装了你所需要的转码规则之后，将其添加到 .babelrc 文件中： 1234567&#123; \"presets\": [ \"env\", \"react\" ], \"plugins\": []&#125; 通过webpack使用Babel安装1npm install --save-dev babel-loader babel-core 配置123456789module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader' &#125; ];&#125; 创建.babelrc配置文件1npm install babel-preset-env --save-dev 123&#123; \"presets\": [\"env\"]&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"前端工具","slug":"前端工具","permalink":"https://langliu.github.io/tags/前端工具/"}]},{"title":"ES2015关于类的概念","slug":"ES2015关于类的概念","date":"2017-09-16T00:02:41.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/09/16/ES2015关于类的概念/","link":"","permalink":"https://langliu.github.io/2017/09/16/ES2015关于类的概念/","excerpt":"基本概念最近又复习了一下原型和原型链的知识，对比ES2015中的类，突然感觉原型链好麻烦，许多语法都不够简洁。 如果使用ES2015中的Class定义类像是下面这样的：","text":"基本概念最近又复习了一下原型和原型链的知识，对比ES2015中的类，突然感觉原型链好麻烦，许多语法都不够简洁。 如果使用ES2015中的Class定义类像是下面这样的： 12345678910class Person &#123; constructor(name, sex) &#123; this.name = name; this.sex = sex; &#125; toString() &#123; console.log(`name: $&#123;this.name&#125;, sex: $&#123;this.sex&#125;`); &#125;&#125; 如果使用ES5的语法则是这样的： 12345678function Person(name, sex) &#123; this.name = name; this.sex = sex;&#125;Person.prototype.toString = function () &#123; console.log(`name: $&#123;this.name&#125;, sex: $&#123;this.sex&#125;`);&#125;; ES6 的类，完全可以看作构造函数的另一种写法。 123456class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 Class表达式与函数一样，类也可以使用表达式的形式定义。 1234567const MyClass = class Me &#123; getClassName() &#123; return Me.name; &#125;&#125;;Me.getClassName(); // ReferenceError: Me is not defined name属性由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 12class Point &#123;&#125;Point.name // \"Point\" name属性总是返回紧跟在class关键字后面的类名。 Class 的取值函数（getter）和存值函数（setter）与 ES5 一样，在”类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 1234567891011121314class Person &#123; constructor(name, sex) &#123; this.name = name; this.sex = sex; &#125; get getName() &#123; return this.name; &#125; set setName(name) &#123; this.name = name; &#125;&#125; Class的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为”静态方法”。 如果静态方法包含this关键字，这个this指的是类，而不是实例。 1234567891011class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;Foo.classMethod() // 'hello'var foo = new Foo();foo.classMethod()// TypeError: foo.classMethod is not a function new.target属性ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 Class 内部调用new.target，返回当前 Class。 123456789class Rectangle &#123; constructor(length, width) &#123; console.log(new.target === Rectangle); this.length = length; this.width = width; &#125;&#125;var obj = new Rectangle(3, 4); // 输出 true 需要注意的是，子类继承父类时，new.target会返回子类。 Class 的继承Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。 12345678910111213class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 调用父类的constructor(x, y) this.color = color; &#125;&#125; 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。子类必须在constructor方法中调用super方法，否则新建实例时会报错。 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。如果像下面这样就会报错： 12345678910111213class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; this.color = color; // Error super(x, y); // 调用父类的constructor(x, y) &#125;&#125; 判断一个类是否继承了另一个类Object.getPrototypeOf方法可以用来从子类上获取父类。 1Object.getPrototypeOf(ColorPoint) === Point; // true supersuper 这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况， super 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super 函数。 第二种情况， super 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 ES6 规定，通过super调用父类的方法时，super会绑定子类的this。 123456789101112131415161718192021class A &#123; constructor() &#123; this.x = 1; &#125; print() &#123; console.log(this.x); &#125;&#125;class B extends A &#123; constructor() &#123; super(); this.x = 2; &#125; m() &#123; super.print(); &#125;&#125;let b = new B();b.m() // 2 上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://langliu.github.io/tags/JavaScript/"}]},{"title":"JSON格式","slug":"JSON格式","date":"2017-09-14T23:26:50.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/09/14/JSON格式/","link":"","permalink":"https://langliu.github.io/2017/09/14/JSON格式/","excerpt":"JSON的全称是“JavaScript Object Notation”，意思是JavaScript对象表示法。它是一种基于文本，独立于语言的轻量级数据交换格式。","text":"JSON的全称是“JavaScript Object Notation”，意思是JavaScript对象表示法。它是一种基于文本，独立于语言的轻量级数据交换格式。 JSON构建于两种数据结构： “名称：值”对的集合 值的有序列表（数组） JSON的值可以是： 数字 字符串（JSON的字符串必须使用双引号） 布尔值 数组 对象 null 在JavaScript中使用JSON将JSON对象转换成字符串——JSON.stringify()JSON.stringify() 方法将一个JavaScript值转换为一个 JSON 字符串，如果指定了一个 replacer 函数，则可以替换值，或者如果指定了一个 replacer 数组，可选地仅包括指定的属性。 JSON.stringify() 方法接收三个参数： 第一个参数JavaScript对象 第二个参数为一个数组或一个函数 如果参数为数组，那么 JSON.stringify() 的结果中将只包含数组中列出的属性 如果参数为函数，该函数接收两个参数：一个键和一个值，对传入的对象进行操作，如果该函数返回 undefined ，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。 第三个参数为字符串缩进的空格数（不超过10） 将字符串转换成JSON对象——JSON.parse()JSON.parse() 方法接收两个参数，第一个参数是要解析的JSON字符串，第二个参数是一个函数，该函数接收两个参数：一个键和一个值，对传入的JSON字符串进行操作，如果该函数返回 undefined ，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。 若被解析的 JSON 字符串是非法的，则会抛出一个语法错误异常。","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://langliu.github.io/tags/JavaScript/"}]},{"title":"Angular路由","slug":"路由","date":"2017-06-22T15:53:40.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/06/22/路由/","link":"","permalink":"https://langliu.github.io/2017/06/22/路由/","excerpt":"为什么需要路由在应用程序中定义路由非常有用，因为我们可以： 将应用程序划分为多个分区 维护应用程序的状态 基于某些规则保护应用分区 使用路由能使我们定义URL字符串，指定用户在应用中的位置。","text":"为什么需要路由在应用程序中定义路由非常有用，因为我们可以： 将应用程序划分为多个分区 维护应用程序的状态 基于某些规则保护应用分区 使用路由能使我们定义URL字符串，指定用户在应用中的位置。 客户端路由的工作原理Angular应用是单页面应用程序，服务器只提供一个页面，负责渲染各种页面的是Javascript。 使用锚标记单页面应用程序客户端框架使用的方式是：将锚标记作为路径来格式化，用它们代表应用程序的路由。 HTML5客户端路由随着HTML5的引入，浏览器获得了新的能力：在不需要新请求的情况下，允许在代码中创建新的浏览器记录项并显示适当的URL。 在Angular中，HTML5路由是默认的模式。 路由配置我们使用三种主要部件来配置Angular路由： Routes：描述了应用程序支持的路由配置 RouterOutlet：这是一个”占位符”组件，用于告诉Angular要把每个路由的内容放在哪里 RouteLink：用于创建各种路由链接 导入为了使用Angular的路由器，首先从@angular/router库中导入一些常量。 1import &#123; RouterModule, Routes &#125; from '@angular/router'; 路由配置123456789101112131415const routes: Routes = [ &#123; path: 'home', component: HomeComponent &#125;, &#123; path: 'about', component: AboutComponent &#125;, &#123; path: '', redirectTo: 'home', pathMatch: 'full' &#125;]; 参数说明 path：指定了该路由要处理的URL路径 component：用于连接当前路由路径与处理该路由的组件 redirectTo：一个可选选项，用于将当前路径重定向到另一个已知路由 安装路由配置在NgModule中的imports数组里使用RouterModule.forRoot(routes)来安装路由配置。 1234imports: [ BrowserModule, RouterModule.forRoot(routes) // &lt;-- routes] 使用&lt;router-outlet&gt;调用RouterOutlet指令将&lt;router-outlet&gt;&lt;/router-outlet&gt;放在你需要渲染组件的地方，当你路由到该组件时，该指令会替换为该路由的组件。 使用[routerLink]调用routerLink指令在不重载页面的情况下链接路由，我们需要使用routerLink指令 1234&lt;ul&gt; &lt;li [routerLink]=\"['home']\"&gt;Home&lt;/li&gt; &lt;li [routerLink]=\"['about']\"&gt;About&lt;/li&gt;&lt;/ul&gt; 使用[routerLink]将指示Angular获得click事件的所有权，然后基于路由的定义，初始化路由并导航到正确的位置。 路由策略定位策略是Angular应用从路由定义进行解析和创建路径的方式。 Angular的默认策略为PathLocationStrategy，也就是HTML5路由。在使用这个策略时，路由的路径是常规路径，例如/home或者/about。 使用HTML5路由时，如果刷新页面，我们向服务器索要的就不是服务器提供的根URL，而是/home或者/about。因为服务器端没有对应的/home或者/about页面，所以它会返回404。 而使用锚点标记策略时，例如/#/home或者/#/about时，服务器将它们解析为/路径。刷新页面时，则会找到正确的页面。 使用锚点标记策略导入1import &#123; LocationStrategy, HashLocationStrategy &#125; from '@angular/common'; 配置123providers: [ &#123; provide: LocationStrategy, useClass: HashLocationStrategy &#125;] 路由参数有时候，我们需要在一个应用程序中导航到特定的页面。比如说一个购物网站，我们需要从首页的商品中点击一个商品进入它的详情页，那么我们可能会使用以下这种URL： 1/productdetail/1 很显然，这么多商品我们不可能给每一个商品都写一个路由，这时候，我们就需要使用路由参数。 配置我们需要在路径前加一个冒号，设定路由接收一个参数： 123456789101112131415const routes: Routes = [ &#123; path: 'home', component: HomeComponent &#125;, &#123; path: 'productdetail/:id', component: ProductDetailComponent &#125;, &#123; path: '', redirectTo: 'home', pathMatch: 'full' &#125;]; 使用为了使用路由参数，我们首先需要导入ActivatedRoute： 1import &#123; ActivatedRoute &#125; from '@angular/router'; 接下来，我们需要将ActivatedRoute注入组件的构造函数中： 1234567export class ProductDetailComponent &#123; id: string; constructor(private route: ActivatedRoute) &#123; route.params.subscribe(params =&gt; &#123; this.id = params['id']; &#125;); &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://langliu.github.io/tags/Angular/"}]},{"title":"图片垂直居中","slug":"图片垂直居中","date":"2017-06-21T23:53:40.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/06/21/图片垂直居中/","link":"","permalink":"https://langliu.github.io/2017/06/21/图片垂直居中/","excerpt":"图片垂直居中在写项目的时候，我想让一张图片垂直居中，可是又不知道怎么做，于是在网上找了一些方案，一下的方法都经过我自己的试验，在我的代码中是能够实现图片垂直居中的效果的","text":"图片垂直居中在写项目的时候，我想让一张图片垂直居中，可是又不知道怎么做，于是在网上找了一些方案，一下的方法都经过我自己的试验，在我的代码中是能够实现图片垂直居中的效果的 利用display:table-cell12345678910div &#123; height: 100vh; display: table-cell; vertical-align: middle; text-align: center; img &#123; vertical-align: middle; &#125;&#125; 背景法123456div &#123; width: 100%; border: 1px solid #f00; height: 100vh; background: url(/assets/images/068a74df58cae466fb7c6d173ce75d9a0b60ac081f807-r0XXgn.jpg) center no-repeat;&#125; 图片外面用个p标签，通过设置line-height使图片垂直居中12345678910111213div &#123; width: 100%; height: 100vh; text-align: center; p &#123; line-height: 100vh; img &#123; vertical-align: middle; &#125; &#125;&#125; 利用flex布局123456div &#123; height: 100vh; display: flex; flex-direction: column; justify-content: center;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://langliu.github.io/tags/CSS/"}]},{"title":"JavaScript作用域","slug":"JavaScript-Scopes","date":"2017-03-21T00:00:00.000Z","updated":"2019-06-28T17:54:44.738Z","comments":true,"path":"2017/03/21/JavaScript-Scopes/","link":"","permalink":"https://langliu.github.io/2017/03/21/JavaScript-Scopes/","excerpt":"作用域是什么几乎所有的编程语言最基础的功能之一，就是能够储存变量当中的值，并且能够在之后对这个值进行访问和修改。但是这些变量存储在哪里？程序需要的时候怎么找到这些变量呢？这时就需要一套设计良好的规则来存储变量，并且可以方便地找到这些变量，这套规则被称为作用域。","text":"作用域是什么几乎所有的编程语言最基础的功能之一，就是能够储存变量当中的值，并且能够在之后对这个值进行访问和修改。但是这些变量存储在哪里？程序需要的时候怎么找到这些变量呢？这时就需要一套设计良好的规则来存储变量，并且可以方便地找到这些变量，这套规则被称为作用域。 所以说，作用域是一套规则，用于确定在何处以及如何查找变量。 词法作用域词法作用域就是定义在词法阶段的作用域。简单说，就是由你写代码时写在哪里来决定的。 12345678function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log(a, b, c); &#125;&#125;foo(2); // 2, 4, 12 上面的代码有三个逐级嵌套的作用域，在 js 中词法作用域规则: 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用规则首先使用提升规则分析. 作用域查找会在找到第一个匹配的标识符时停止. 欺骗词法由于词法作用域在写代码的时候就已经确定了，那么我们怎么才能在运行的时候来修改词法作用域呢？ 在JavaScript中有两种机制来实现这个目的（eval和with）。但这两种机制并不是什么好主意，因为他们会导致性能的下降，所以不推荐使用欺骗词法，只要知道有这么个东西就好了。 evalJavaScript中的eval(..)可以接受一个字符串作为参数，并将其中的内容视为好像在书写就存在于程序中这个位置的代码。 12345678function foo(str, a) &#123; eval(str); //欺骗 console.log(a, b);&#125;var b = 2;foo(\"var b = 1;\", 1); // 1, 1 从上面代码可以看出，当eval(..)调用传进去的字符串时，程序把该字符串当做本来就在那里一样来处理。因为在字符串中定义了变量b，所以外部的变量b被屏蔽了。 withJavaScript中另一个欺骗词法作用域的机制就是with关键字。 12345678910111213function foo(obj) &#123; with(obj) &#123; a = 2; &#125;&#125;var obj = &#123; b: 3&#125;;foo(obj);console.log(obj.a); // undefinedconsole.log(a); // 2 在上面的代码中，当执行foo(obj)时，obj并没有a属性，因此obj.a为undefined。但是在foo(..)函数中a = 2;却创建了一个全局变量a。 在严格模式的程序中，eval(..)在运行时有着自己的词法作用域，意味着其中的声明无法修改所在的作用域，而with则被完全禁止了。 函数作用域函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用。 函数的用途 隐藏内部实现 代码复用 组合调用 立即执行函数表达式（IIFE）123456var a = 2;(function foo() &#123; var a = 3; console.log(a); // 3&#125;)();console.log(a); // 2 由于函数被包含在一对( )括号内部，因此成为了一个表达式，通过在末尾加上另外一个( )可以立即执行这个函数。 两种形式 (function(){ .. })() (function(){ .. }()) 块作用域我在《JavaScript语言精粹》中看到过这样一句话“糟糕的是，尽管Javascript的代码块语法貌似支持块级作用域，实际上JavaScript并不支持。这个混淆之处可能成为错误之源。” 1234for (var i = 0; i &lt; 10; i++) &#123; console.log(i);&#125;console.log(i); // 10 在上面的代码中，我们可以看到在for循环内部定义的变量污染到了全局作用域中。 那么JavaScript中真的没有块作用域吗？很少有人注意到JavaScript的ES3规范中规定try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效。 123456try &#123; undefined();&#125; catch (error) &#123; console.log(error); // 能够正常运行&#125;console.log(error); // 在ES6中，引入了新的let关键字，提供了除了var以外的另一种变量声明方式。let关键字可以将变量绑定到所在的任意作用域中（通常是{ ... }内部） 1234for (let i = 0; i &lt; 10; i++) &#123; console.log(i);&#125;console.log(i); // ReferenceError: i is not defined 对比上面的代码，我们可以发现使用let关键字时，块作用域外部并不能访问内部的变量。 除了let以外，ES6还引入了const，同样可以用来创建块作用域变量，但其值是固定的（常量），之后任何试图修改值的操作都会引起错误。","categories":[{"name":"前端","slug":"前端","permalink":"https://langliu.github.io/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://langliu.github.io/tags/JavaScript/"}]}]}